<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>The Wall</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="a18971c5-e183-45d5-867c-09342aa31c44" class="page sans"><header><div class="page-header-icon undefined"><img class="icon" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/icon.png"/></div><h1 class="page-title">The Wall</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-text"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/rocket_gray.svg" style="width:14px;height:14px"/></span>Finished</th><td>Jun 2023</td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/gear_gray.svg" style="width:14px;height:14px"/></span>Engine &amp; Language</th><td><span class="selected-value select-value-color-pink">C#</span><span class="selected-value select-value-color-purple">Unity</span></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/briefcase_gray.svg" style="width:14px;height:14px"/></span>Roles</th><td><span class="selected-value select-value-color-blue">Game Dev</span></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/tag_gray.svg" style="width:14px;height:14px"/></span>Tags</th><td><span class="selected-value select-value-color-green">2D</span><span class="selected-value select-value-color-green">Arcade</span><span class="selected-value select-value-color-yellow">Game Jam</span><span class="selected-value select-value-color-green">Top-Down Shooter</span></td></tr><tr class="property-row property-row-number"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/groups_gray.svg" style="width:14px;height:14px"/></span>Team Size</th><td>2</td></tr><tr class="property-row property-row-text"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/clock-alternate_gray.svg" style="width:14px;height:14px"/></span>Development Period</th><td>2 Days</td></tr><tr class="property-row property-row-url"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesUrl"><path d="M7.69922 10.8945L8.73828 9.84863C7.91797 9.77344 7.34375 9.51367 6.91992 9.08984C5.76465 7.93457 5.76465 6.29395 6.91309 5.14551L9.18262 2.87598C10.3379 1.7207 11.9717 1.7207 13.127 2.87598C14.2891 4.04492 14.2822 5.67188 13.1338 6.82031L11.958 7.99609C12.1768 8.49512 12.2451 9.10352 12.1289 9.62988L14.0908 7.6748C15.7725 6 15.7793 3.62109 14.084 1.92578C12.3887 0.223633 10.0098 0.237305 8.33496 1.91211L5.95605 4.29785C4.28125 5.97266 4.26758 8.35156 5.96289 10.0469C6.36621 10.4434 6.90625 10.7441 7.69922 10.8945ZM8.30078 5.13184L7.26855 6.17773C8.08203 6.25293 8.66309 6.51953 9.08008 6.93652C10.2422 8.09863 10.2422 9.73242 9.08691 10.8809L6.81738 13.1504C5.66211 14.3057 4.03516 14.3057 2.87305 13.1504C1.71094 11.9883 1.71777 10.3545 2.87305 9.20605L4.04199 8.03027C3.83008 7.53125 3.75488 6.92969 3.87109 6.39648L1.91602 8.35156C0.234375 10.0264 0.227539 12.4121 1.92285 14.1074C3.61816 15.8027 5.99707 15.7891 7.67188 14.1143L10.0439 11.7354C11.7256 10.0537 11.7324 7.6748 10.0371 5.98633C9.64062 5.58301 9.10059 5.28223 8.30078 5.13184Z"></path></svg></span>Link</th><td><a href="https://dureddu.itch.io/the-wall" class="url-value">https://dureddu.itch.io/the-wall</a></td></tr></tbody></table></header><div class="page-body"><p id="fa3c42bc-9355-4417-963d-2a1f17eb9270" class="">‚¨ÖÔ∏è Back to the <a href="../../Portfolio%2096ace5e3bf2a452f8176fc2dc7f16779.html"><span class="icon">üöÄ</span>Portfolio</a></p><ul id="ddda98ae-02dc-4ef7-b28f-c39d2a76d05a" class="toggle"><li><details open=""><summary>üß≠ <strong>Quick Links</strong></summary><nav id="1c391ed2-6092-495c-b7a7-37c42470f2d2" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#370c04dc-e3f7-4967-bf4d-00a671dfc642">Context &amp; Description</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#a1c06a90-2333-45b4-a439-819a8bde616a">Images &amp; Videos</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e76bc0a9-d96a-4e36-b64c-42a5f088de58">Team</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d74f6341-c2b1-408f-8d2e-0ac520cedd4e">Contributions</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#a9e7bb53-d20d-4613-88df-37b81bfd110b">Process</a></div></nav></details></li></ul><h2 id="370c04dc-e3f7-4967-bf4d-00a671dfc642" class="block-color-pink_background">Context &amp; Description</h2><hr id="a3d82573-71da-45d7-9fd5-453edc7e15b5"/><div id="b34b2c7b-a604-4b49-b096-57c32c365b1f" class="column-list"><div id="c17ceb96-7193-45f6-a3b3-d50d33af91fe" style="width:50%" class="column"><figure id="e2e3f578-1b67-4aa2-b7c1-fefe1edab740" class="image" style="text-align:left"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/icon%201.png"><img style="width:630px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/icon%201.png"/></a></figure></div><div id="ff8fd25a-d982-4cc7-b7e4-06b9b7992098" style="width:50%" class="column"><p id="5f61c75c-572c-4776-a13e-42a5c30abf17" class="">In June 2023 I participated in the Semester Game Jam at TUM. The topic was ‚ÄúShapeshift‚Äù. My team members came up with the game‚Äôs concept: a top down shooter with three switchable characters, each representing a different shape: Circle, Square and Triangle. They all have their own weapon, special ability and weight. The heavier an entity, the fewer knockback it receives, so choose carefully who you play. Over time, enemies of random shapes spawn. Bullets do not make damage, but only exert a knockback force on the hit entity. Entities bounce of walls, so do bullets. At the bottom there is a big hole. The only way to kill an enemy is to knock him in said hole by shooting at him from the right angle. But there is a twist: A wall spanning across the whole screen regularly moves from the top to the bottom, taking anything with it (player and enemies) that does not match the shape displayed on the wall. At this moment you have to switch to the correct shape, otherwise you‚Äôll fall and the game is over.</p><p id="f735c70a-5b8b-461b-b74f-9afd0e3eded0" class=""><mark class="highlight-pink"><strong>The Wall</strong></mark><mark class="highlight-blue"><strong> </strong></mark><mark class="highlight-default">was created over the span of a weekend (~48h) by two developers and one composer.</mark></p><p id="777d8c98-0e6e-4975-a29b-7d1bc1054229" class="">
</p></div></div><h2 id="a1c06a90-2333-45b4-a439-819a8bde616a" class="block-color-pink_background">Images &amp; Videos</h2><hr id="7df4de2e-7f51-4b81-8192-d7b5a3c4b506"/><div id="3cb1dac0-02e7-4937-8d3e-484f078b10d2" class="column-list"><div id="55aee4c8-b505-4a04-859f-3cabdea9eef2" style="width:50%" class="column"><figure id="d1804895-04e3-4360-be11-1d12c014fa86" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/MainMenu.png"><img style="width:1549px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/MainMenu.png"/></a><figcaption>Main Menu / Start Screen</figcaption></figure></div><div id="3270b658-93e6-48ce-8ad6-91d00716bf43" style="width:16.66666666666668%" class="column"><figure id="2bd528ba-a160-483e-82f7-a367f5ea83f5" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Circle.png"><img style="width:381px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Circle.png"/></a><figcaption>Circle player</figcaption></figure><figure id="5f99b0a3-f68c-4e2e-a412-f3246430a03d" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/TriangleEnemy.png"><img style="width:139px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/TriangleEnemy.png"/></a><figcaption>Triangle enemy</figcaption></figure></div><div id="ce1018db-b3e6-473e-af12-f8349ca4aa4e" style="width:33.33333333333333%" class="column"><figure id="e05a282a-deda-4c79-8ddf-df28be8ae030" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/EnemyShootsPlayer.png"><img style="width:648px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/EnemyShootsPlayer.png"/></a><figcaption>Player and enemy fighting</figcaption></figure><figure id="572a776b-206f-48bf-8787-2cbf067b6e7c" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/WallPushingCircle.png"><img style="width:859px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/WallPushingCircle.png"/></a><figcaption>Wall of type square pushing circle enemy</figcaption></figure></div></div><h2 id="e76bc0a9-d96a-4e36-b64c-42a5f088de58" class="block-color-pink_background">Team</h2><hr id="b2acc838-d835-44f5-bbfa-5820bd957aca"/><ul id="323d6e10-7ff1-4c6b-8e93-f1b54d7dc318" class="bulleted-list"><li style="list-style-type:disc">Kerstin Pfaffinger (me): object pooling (bullets, enemies), enemy spawning, grapple ability, dotted line, the wall</li></ul><ul id="108876bc-75c5-4613-9409-f8918ca91c3b" class="bulleted-list"><li style="list-style-type:disc">Phillip Brechtmann: Art, player controller, enemy AI, main menu, dash and square abilities</li></ul><ul id="1a3a7d86-ac2c-474e-8068-39146f221db1" class="bulleted-list"><li style="list-style-type:disc">Nick Tordalk: Music and sound effects</li></ul><p id="5cfef7ac-47b1-4c72-98f9-57928a7e2d89" class="">
</p><h2 id="d74f6341-c2b1-408f-8d2e-0ac520cedd4e" class="block-color-pink_background">Contributions</h2><hr id="faf4a788-5a4f-4576-827e-203ae7e5906d"/><ul id="008fa797-8345-49c0-af55-e0854182715d" class="bulleted-list"><li style="list-style-type:disc"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44.html"><mark class="highlight-pink"><strong>Grapple Ability</strong></mark></a><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>:</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong> The circle character carries a grappling hook, which can be thrown towards enemies. After it has travelled a fixed distance, it returns if nothing was hit. If an enemy gets hit by the grapple, the hook sticks to it. By pressing the ability button again, the grapple returns to the player, pulling the enemy towards the player. The player can carefully position himself between the enemy and the hole to pull the enemy into it.</li></ul><ul id="1150b684-c9c1-48c9-801d-1b6b5de4d817" class="bulleted-list"><li style="list-style-type:disc"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44.html"><strong><mark class="highlight-pink">Enemy Spawning</mark></strong></a>: Randomly shaped enemies spawn in waves at certain positions in the room</li></ul><ul id="2d1826d4-3407-4aad-a7cc-0cf630da9254" class="bulleted-list"><li style="list-style-type:disc"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44.html"><mark class="highlight-pink"><strong>Player Orientation and Dotted Line Indication</strong></mark></a>: The player always looks at the mouse position. The direction is also shown by a dotted line.</li></ul><ul id="2b9000c7-30db-496e-a69e-70f78505a3dd" class="bulleted-list"><li style="list-style-type:disc"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44.html"><mark class="highlight-pink"><strong>The Wall Itself</strong></mark></a>: The wall moves across the screen once in a while, wiping all entities that have a different shape than itself.</li></ul><p id="8c3c9f64-c3d5-42ef-8316-d3559f59d56d" class="">
</p><h2 id="a9e7bb53-d20d-4613-88df-37b81bfd110b" class="block-color-pink_background">Process</h2><hr id="dc112396-1f8c-41f5-a30c-24e5d0acadff"/><p id="200abed0-1c82-42ba-ba51-9bbc29a5a154" class=""><mark class="highlight-pink"><strong>Grapple Ability</strong></mark></p><p id="5ff9de7d-b19c-47de-955a-72ae508718ee" class="">The hook uses rigidbody forces to move, like any other entity including the bullets. First thing to consider was that the hook should only collide with enemies, not with bullets, so I created an extra layer for it.</p><p id="f6227b1c-9b73-4d09-8122-a87f2ee890b7" class="">The hook also had to return to the correct position relative to the player‚Äôs position. Otherwise it would keep the rotation of the enemy it was stuck on. I achieved this by resetting the grapples transform after adding it as a child of the player. But the grapple was scaled down a bit by default, so instead of resetting the transform, I saved its transform values in <code>Start</code> and reset it to this value.</p><p id="cc9819fd-3fb8-49e7-bb1e-fa170f3e4a6f" class="">A problem I faced was that as soon as the hook stuck to an enemy, that enemy would move weirdly. After thinking about it and testing, I found out that the weight of the grapple‚Äôs rigidbody would drag the enemy down. So I disabled it‚Äôs rigidbody component in the respective <code>OnTriggerEnter</code> method.</p><ul id="772ecf5b-8ada-4fec-a65d-cb700c54adb2" class="toggle"><li><details open=""><summary><em>[Script]</em> GrappleAbility.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15d67251-6f4d-4628-812e-0c4a2c89764c" class="code"><code class="language-C#">using System.Collections;
using UnityEngine;

namespace Abilities
{
    public class GrappleAbility : Ability
    {
        [SerializeField] private float pullStrength = 1;
				[SerializeField] private float resetTime = 1;

        private Transform _attackedEnemy; // enemy that is currently hit by the grapple
        private Grapple _grapple;
        private bool _attacked;


        private void Start()
        {
            _grapple = GetComponentInChildren&lt;Grapple&gt;();
        }

        protected override void DoAbility()
        {
						// when first pressing the ability button, the grapple is thrown.
					  // When pressed again while stuck on and attacking an enemy, it is pulled back.
            if (_attacked)
            {
                PullEnemy();
                return;
            }
            
            _grapple.Fire();
        }

        public void SetAttacked(Transform attacked)
        {
            _attackedEnemy = attacked;
            _attacked = true;
            Ready = true; // member of parent class Ability
        }


        private void PullEnemy()
        {
						// this script is attached to the player shape as it performs any abilities.
						// To get the vector between enemy and player therefore use this.transform.position
            var dir = transform.position - _grapple.transform.position;
            var enemyRB = _attackedEnemy.GetComponent&lt;Rigidbody2D&gt;();
            
						// pull enemy towards player
            enemyRB.AddForce(dir.normalized * pullStrength, ForceMode2D.Impulse);

						// Reset grapple
            _attackedEnemy = null;
            _attacked = false;

            StartCoroutine(nameof(WaitAndReset));
        }

        private IEnumerator WaitAndReset()
        {
            yield return new WaitForSeconds(resetTime);
            ResetAbility();
        }

        private void ResetAbility()
        {
            _grapple.ResetGrapple();
        }
    }
}</code></pre></details></li></ul><ul id="1240a9ac-6484-42e0-9a68-313a920d1e34" class="toggle"><li><details open=""><summary><em>[Script]</em> GrappleHook.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1c87e9dc-43aa-4da9-83cd-bacade5a9fca" class="code"><code class="language-C#">using UnityEngine;

namespace Abilities
{
    public class Grapple : MonoBehaviour
    {
        [SerializeField] private float speed = 6;
        [SerializeField] private float maxRange = 7; // distance the grapple can travel when thrown

        private GrappleAbility _grappleAbility;
        private Vector3 _grapplePos;
        private Vector3 _defaultPos;
        private bool _fired;

        private void Start()
        {
            _grappleAbility = GetComponentInParent&lt;GrappleAbility&gt;();
            _defaultPos = transform.localPosition;
        }
        
        private void Update()
        {
            if (!_fired) return;

            transform.position += transform.right * (speed * Time.deltaTime);
            
            if (Vector3.Distance(transform.position, _grapplePos) &gt; maxRange)
            {
                ResetGrapple();
            }
        }

        private void OnCollisionEnter2D(Collision2D other)
        {
            _fired = false;
            Transform enemy = other.transform;
            _grappleAbility.SetAttacked(enemy);
            transform.parent = enemy;
        }

        public void Fire()
        {
            _fired = true;
						
						// set position from which grapple was thrown to calculate travelled distance in Update()
            _grapplePos = transform.position;

						// detatch grapple from player to avoid adapting its rotation and translation while being thrown
            transform.parent = null;
        }
        
        public void ResetGrapple()
        {
            _fired = false;

						// GrappleAbility component is attached to player shape
            transform.parent = _grappleAbility.transform;

						// position grapple correctly relative to player shape
            transform.localPosition = _defaultPos;
            transform.localRotation = Quaternion.identity;
        }
    }
}</code></pre></details></li></ul><p id="a8806fe2-f1d3-44b2-b3e8-db0e40c97f0d" class="">
</p><p id="fb04053c-9491-40b5-88da-fe9604d488e8" class="">
</p><p id="087fdd9f-f2fa-4b61-a1a3-4414be582476" class="block-color-pink"><strong>Enemy Spawning: Object Pooling and Wave Balancing</strong></p><p id="44edd19d-f721-49d3-8f57-63f3578fa3d9" class="">I decided to employ the pool pattern for spawning the enemies. Meaning, enemies are not instantiated from a prefab and deleted when falling into the hole, but rather a bunch of inactive enemies are kept outside the viewing frustum and are managed by an <code>EnemyPool</code> object. Any time an enemy should spawn, the pool gets a request to spawn an enemy. It will activate one of the enemy objects in the pool and move it to the desired position. Any time an enemy is defeated, it is moved back to the pool, its values are reset and it gets deactivated. I used the same pattern for the bullets. In that case it makes even more sense, as there are always multiple bullets shot at the same time, so instantiating could cause lags in the worst case. Value reset for an enemy especially means to scale him back to normal as it was shrunken down falling into the hole. The pool keeps a list of inactive enemies that are ready to be spawned. Said list is initialized with all the pool‚Äôs child objects on <code>Awake</code>. Any time an enemy spawns, it is removed from the list. A dead enemy will inform the pool that it is ready for reset and the pool adds it back to the list. I made sure to add more than enough children to the pool to avoid any exceptions like trying to access an element of an empty list. As an additional safety measure, I checked if the requested amount of new enemies was higher than the number of remaining inactive enemies in the list and in that case stopped after the list was empty.</p><p id="30bab9a0-5264-499d-970f-da2e6575d1b5" class="">The pool also controls how many enemies are spawned in the next wave and modifies the enemy‚Äôs fire rate when spawning them. This way, the game gets increasingly harder over time.</p><p id="f670b0b0-1de8-4529-8b54-ca7a57284273" class="">We wanted the new enemies to have random shapes. I achieved that by shuffling the enemy list whenever a new wave was about to spawn. I then activated the enemies one after another. This way, I could add the enemies to the pool grouped by shape while still spawning a diverse enemy wave.</p><p id="64243df4-61bd-431b-983c-43f3e545cef9" class="">In addition to shuffling I wrote some other C# list extension methods for popping the first list element so that I could reuse them for the bullet pool.</p><p id="a842125a-85b1-4696-a0b8-8f3ea8fc5657" class="">Enemies spawn on special positions in the room. Those were selected manually and all spawn points are collected in a list of <code>Transform</code>s. For each wave, the pool draws a random set of spawn points to distribute the enemies. This is, again, done by shuffling the list and choosing the points incrementally. I quickly realized that I run into a problem as soon as there are more enemies to be spawned simultaneously as there are spawn points in said list. So I added a wraparound returning to the first list item as soon as the enemy count exceeded the number of available spawn points.</p><p id="78bb32d5-c711-4654-95f2-b7779a45e38a" class="">There were still two major problems with my spawning system:</p><p id="5927073a-d7b5-4b59-8fa6-498d00c291c5" class="">Originally, enemies spawned only after the wall crossed the room. So if the player managed to defeat all enemies before that, there was nothing to do anymore until the next wall would spawn. To remedy this, I checked the number of active enemies whenever an enemy was re-added to the pool. If so, I initiated a new wave.</p><p id="462002a7-4f77-469e-a047-67468ce4d641" class="">Contrary to that, there was also the case that too much enemies appeared simultaneously. The wall only wiped those enemies that had a different shape than the wall. Originally I would simply spawn an enemy wave whenever the wall reached the bottom of the screen. But in the case that lots of enemies happened to survive the wall due to their shape, adding another group of enemies was overwhelming and didn‚Äôt feel fair. So I, again, added a check to see if there are more than two enemies remaining and refrained from spawning new ones if that was the case. When the player got rid of those, a new wave would come anyways.</p><p id="03273d77-0915-4926-97ab-70dacf2dc788" class="">These last changes brought more balance to the game. </p><ul id="b7a76b19-a23d-4709-bd2d-2a3c64d95f5c" class="toggle"><li><details open=""><summary><em>[Script]</em> EnemyPool.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2e44e7e5-3f67-4855-ace4-180224f9182c" class="code"><code class="language-C#">public class EnemyPool : MonoBehaviour
{
    [Header(&quot;Enemy Properties&quot;)]
    [SerializeField] private List&lt;Transform&gt; spawnPositions = new();
    [SerializeField] private int initialEnemyCount = 1;
    [SerializeField] private float initialShotInterval = 3;
			
		// ...

    private float _shotInterval;
    private int _enemyCount;
    private const float MinimalShotInterval = 0.15f;
    private Vector3 _poolPos;
    private List&lt;Transform&gt; _enemies = new();
    private int _spawnCounter;
		// ...
    private int _currentGroupSize;
    private const int MaximalEnemiesOnField = 2;
		private Vector3 _originalScale = new(1, 1);


		private void Start()
		{
				// cache reference to position
		    _poolPos = transform.position;
		
		    // ...
		
		    InitEnemies();
		
				// spawn first group at the beginning
		    SpawnEnemyGroup();
		}
		
		private void InitEnemies()
		{
		    for (int i = 0; i &lt; transform.childCount; i++)
		    {
		        _enemies.Add(transform.GetChild(i));
		    }
		}
		
		private void SpawnEnemy(Vector3 position)
		{
				// retrieve next enemy from pool and spawn it at correct position with desired values
		    Transform enemy = _enemies.Pop(); // Pop() is extension method
		    enemy.gameObject.SetActive(true);
		    enemy.position = position;
		
		    Enemy enemyComponent = enemy.GetComponent&lt;Enemy&gt;();
		    enemyComponent.SetShotInterval(_shotInterval);
		}
		
		public void SpawnEnemyGroup()
		{
				// avoid having too many enemies at once
		    if (_currentGroupSize &gt; MaximalEnemiesOnField) return;
		    
				// both using my extension methods
		    ShuffleSpawnPoints();
		    ShuffleEnemies();
		
				// avoid spawning more enemies than are remaining in pool
		    var cappedSpawnAmount = Math.Min(_enemyCount, _enemies.Count);
		    var count = spawnPositions.Count;
		
		    for (int i = 0; i &lt; cappedSpawnAmount; i++)
		    {
						 // spawn point index wraparound by using %
		        var index = i % count;
		        SpawnEnemy(spawnPositions[index].position);
		    }
		
		    _currentGroupSize = cappedSpawnAmount;
		
				// sets size for next wave and updates fire rate for future enemies
		    UpdateEnemyProperties();
		}
		
		// called in Enemy class
		public void ResetEnemy(Transform enemy)
		{
		    enemy.position = _poolPos;
		    enemy.localScale = _originalScale;
		    enemy.gameObject.SetActive(false);
		
		    _enemies.Add(enemy);
		    // ...
		
		    _currentGroupSize--;
		
				// avoid idle time with no enemies to defeat
		    if (_currentGroupSize == 0)
		    {
		        SpawnEnemyGroup();
		    }
		}
}</code></pre></details></li></ul><ul id="47ed2a0d-7767-4b27-a4a6-fc60a1e83313" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em></em> Enemy.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="77829482-5d40-4b3c-9e0e-8f932fbb3744" class="code"><code class="language-C#">public class Enemy : Entity
    {
        [SerializeField] private Transform player;
        private EnemyPool _pool;
        private float _shotInterval;

        // ...

        private void Start()
        {
            _pool = GetComponentInParent&lt;EnemyPool&gt;();
						// ...
        }

        private void Update()
        {
						// ...

            if (IsDoneFalling)
            {
                Reset();
                IsDoneFalling = false;
            }
        }

				// ...

        private void Reset()
        {
						// passes itself to the pool
            _pool.ResetEnemy(transform);
        }
    }</code></pre></details></li></ul><p id="fc827133-0c7a-49df-b015-172ca295c6d3" class="">
</p><p id="2807b089-cf16-4574-acab-584f6ab8975c" class="">
</p><p id="8416e9b7-d133-4e9b-97d8-80922dafbdd0" class="block-color-pink"><strong>Player Orientation and Dotted Line Indication</strong></p><p id="7708e77f-f7ca-4581-98ce-cf83225e05dc" class="">The player always looks towards the mouse position. I adapted a solution for looking at a position in 2D I found on StackOverflow and created a C# extension method <code>LookAt2D</code> for that, so we could reuse it in the future potentially.</p><p id="bb45d9e2-f053-4602-a153-f021a10a79ea" class="">When playing with the circle shape, it was impossible to tell in which direction the player was facing. We would later add a gun and a ability to each shape, then the orientation was more visible. But we still wanted to have a clear indication for the viewing direction so that even if moving in between lots of enemies and bullets the player can still see it with ease. I went for a dotted line between player and mouse fading out after a few dots.</p><p id="348a51ad-1a65-4677-ba55-43ce0d4ef254" class="">I had never done anything like that before and spend much time researching how to implement such a feature. I then decided on using Unity‚Äôs <code>LineRenderer</code>. We also created a custom texture for the line dots.</p><p id="73163621-ff1e-4a49-b111-0ddc70e9bf0e" class="">The line had to start outside the player so if added an offset from the player‚Äôs center and adjusted the line‚Äôs root to start there.</p><p id="b2424178-c98c-46a0-9a09-507829f6850d" class="">The biggest hurdle to overcome was a problem occurring when the mouse was moved over the player. The line had to appear on the opposite side than before. My first approach was to calculate the angle between old line and new mouse position but that turned out to be a huge dead end as this never was the problem‚Äôs cause. As always when I‚Äôm getting stuck on a problem, I start sketching it:</p><div id="b966a866-5368-484f-a552-d40271357f2a" class="column-list"><div id="88414bf0-c110-4233-9842-18e5ba9215f2" style="width:29.166666666666664%" class="column"><figure id="7400ba9a-0060-4ccf-9d67-21df662bb621" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled.png"><img style="width:288px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled.png"/></a></figure></div><div id="1abbde20-e173-4444-a5a0-0ae49631f530" style="width:29.166666666666664%" class="column"><figure id="907b0e35-4542-4850-b729-f10bbe538cc5" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled%201.png"><img style="width:192px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled%201.png"/></a></figure></div><div id="38c5fa6a-3fb8-4734-851d-93aaee16cc47" style="width:41.66666666666666%" class="column"><figure id="05169ca7-60bf-4ee7-a551-985b1091039e" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled%202.png"><img style="width:240px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled%202.png"/></a></figure></div></div><p id="508230b6-0ca5-4e14-b478-8c7f69998916" class="">I realized that the angle had nothing to do with the new line as it is constantly redrawn in <code>Update</code>. The real issue was that the line calculation was not working properly when the mouse was inside the player shape. The line happened to go through the shape in that case like in the third drawing. To fix that, I calculated the distance between the shape‚Äôs center and the mouse position. If it was below a certain threshold, the line would simply disappear as the player doesn‚Äôt look to a point ‚Äúoutside of itself‚Äù.</p><ul id="fdff05f0-9e95-4736-866a-dd539da3cb40" class="toggle"><li><details open=""><summary><em><em>[Script] </em></em>DrawLine() in Player.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="bfe1e491-ae86-408b-8241-d048613632be" class="code"><code class="language-C#">// param target here is the mouse position in our case
private void DrawLine(Vector3 target)
{
    var lineStartPos = transform.position + transform.right * offset;
    var direction = target - lineStartPos;

		// disable line when mouse is inside of player
    bool mouseInsidePlayer = direction.magnitude &lt; offset;
    _lineRenderer.enabled = !mouseInsidePlayer;

    direction = direction.normalized;

    var lineEndPos = lineStartPos + direction * maxLineDistance;

		// tell LineRenderer where to put points + decrease their scale gradually
    Vector3[] points = {lineStartPos, lineEndPos};

    float width = _lineRenderer.startWidth;
    _lineRenderer.material.mainTextureScale = new Vector2(1f / width, 1.0f);

    _lineRenderer.SetPositions(points);
}</code></pre></details></li></ul><p id="615358c4-b202-4015-a1c4-4d9cebcc4b6d" class="">
</p><p id="a2d442e7-6011-41c7-8197-12cc15473ae4" class="">
</p><p id="5d5c2fd4-2ad8-4d71-9b6d-c52ff519647a" class=""><mark class="highlight-pink"><strong>Wall</strong></mark></p><p id="70c3ff62-ef5b-4112-aa6a-265677f4599e" class="">As always when beginning to work on a new feature, I start scribbling down the concepts and noting down the key aspects:</p><div id="01f3adeb-59b2-4085-bb66-57246ca07e63" class="column-list"><div id="622f95e7-43c5-4147-a235-c80c60d7984a" style="width:31.25%" class="column"><figure id="2bc246d0-bef9-4885-8469-afc1c416e985" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled%203.png"><img style="width:288px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled%203.png"/></a></figure></div><div id="2d3a7ba0-15f2-451c-a37a-4e69ab17840e" style="width:68.75%" class="column"><figure id="cba9ff9e-3f60-4195-96c5-f23c36878291" class="image"><a href="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled%204.png"><img style="width:288px" src="The%20Wall%20a18971c5e18345d5867c09342aa31c44/Untitled%204.png"/></a></figure></div></div><p id="65913b4e-6c64-43b0-b5e6-d70c0d2955ce" class="">The wall‚Äôs movement was done quickly. Same for a simple timer. The first interesting thing was how to chose the shape randomly. We already had an <code>enum</code> for the three shapes to chose from. I added a <code>ShapeAccess</code> class providing some methods for accessing <code>Shape</code>. I basically created a list containing all possible shapes and generated a random index to provide a random shape selection functionality:</p><ul id="578aac0c-9cb9-40fb-9c1b-1038aff438a3" class="toggle"><li><details open=""><summary><em><em><em><em><em><em>[Script]</em></em></em></em></em></em> Shape.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="899085fb-def9-4cbe-98a7-0f7620f996a3" class="code"><code class="language-C#">// ... (imports)

public enum Shape
{
    Triangle,
    Square,
    Circle
}

public static class ShapeAccess
{
		// [Source:] https://stackoverflow.com/questions/11240236/enum-values-in-a-list
    private static readonly List&lt;Shape&gt; ShapeValues = Enum.GetValues(typeof(Shape)).Cast&lt;Shape&gt;().ToList();
    private static readonly int NumberOfShapes = ShapeValues.Count;

    public static Shape GetRandomShape()
    {
        var randomIndex = UnityEngine.Random.Range(0, NumberOfShapes); //exclusive end
        return ShapeValues[randomIndex];
    }
}</code></pre></details></li></ul><p id="85936720-aab4-4472-a248-9ff29bb3b3bc" class="">A sprite on the wall then indicates which shape it currently lets through.</p><p id="6eabc6b7-3d12-4200-96cd-7c401a83ce6f" class="">During playtesting, I found that the first wall came far too early. Till then, I had only one variable for the time between wall appearances. I added another public variable to tweak the time till the wall comes in the first time. This way, the player had enough time to get used to the control, the concept and the physics before another element was introduced. The intervals between two walls increases over time. I also added a field for configuring the minimal interval so the game keeps being playable and there is only one wall on the screen at a time.</p><p id="17e136e3-7a75-44a5-bcc2-74e2c61f2632" class="">The full script is here:</p><ul id="0446ad63-1449-44d6-9fc7-a1fd7eb1ae69" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script] </em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>Wall.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="962578e0-b6ae-4a61-b233-e5bc5a0d1d6e" class="code"><code class="language-C#">public class Wall : MonoBehaviour
{
    private Shape _shape;
    private bool _move;

    [Header(&quot;Wall Properties&quot;)]
		[SerializeField] private float speed = 5;
    [SerializeField] private float wallDelay = 15;
    [SerializeField] private float firstWallDelay = 30;
    [SerializeField] private int minimumWallDelay = 5;
    [SerializeField] private int repeatingRateForUpdatingProperties = 3;

    [Header(&quot;Positions&quot;)]
		[SerializeField] private Transform screenTopPos;
    [SerializeField] private Transform screenBottomPos;

    [Header(&quot;Shapes&quot;)]
		[SerializeField] private List&lt;Sprite&gt; banners;
    [SerializeField] private SpriteRenderer bannerRenderer;

    [Header(&quot;Enemy Spawning&quot;)]
		[SerializeField] private EnemyPool enemyPool;
    [SerializeField] private float spawnDelay = 2;

    private float _timer;
    private int _counter;
    private readonly float _threshold = 0.1f;
    private bool _startTimer;

    public void EnableWall()
    {
        gameObject.SetActive(true);
        Invoke(nameof(StartTimer), firstWallDelay);
    }

    private void StartTimer()
    {
        _startTimer = true;
    }


    private void Update()
    {
        if (!_startTimer) return;

        _timer = (_timer + Time.deltaTime) % wallDelay;
        if (_timer &lt; _threshold)
				{ 
						StartWall();
				}

        if (!_move) return;

        var moveVector = Vector3.MoveTowards(transform.position, screenBottomPos.position, speed * Time.deltaTime);
        transform.position = moveVector;

        if (transform.position == screenBottomPos.position)
				{ 
						ResetWall();
				}
    }

    private void StartWall()
    {
        _move = true;
        ChooseRandomShape();
    }

    private void StopWall()
    {
        _move = false;
    }


    private void ResetWall()
    {
        StopWall();
        transform.position = screenTopPos.position;
        UpdateWallProperties();

        StartCoroutine(nameof(WaitAndSpawnNewEnemies));
    }

    private IEnumerator WaitAndSpawnNewEnemies()
    {
        yield return new WaitForSeconds(spawnDelay);
				// tell
        enemyPool.SpawnEnemyGroup();
    }

    private void UpdateWallProperties()
    {
        _counter = (_counter + 1) % repeatingRateForUpdatingProperties;
        if (_counter != 0) return;

        wallDelay = Math.Max(wallDelay - 1, minimumWallDelay);
    }


    private void ChooseRandomShape()
    {
        _shape = ShapeAccess.GetRandomShape();
				// Collision layers are named like this: Wall_&lt;Shape&gt;
        string layerName = &quot;Wall&quot; + _shape;

				// put respective shape icon on wall
        bannerRenderer.sprite = _shape switch
        {
            Shape.Circle =&gt; banners[0],
            Shape.Square =&gt; banners[1],
            _ =&gt; banners[2]
        };

				// apply correct collision mask to let correct shape through and block others
        gameObject.layer = LayerMask.NameToLayer(layerName);
    }
}</code></pre></details></li></ul><p id="7cb9cb67-6ab6-4e81-a386-a7433439bdb0" class="">
</p></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>