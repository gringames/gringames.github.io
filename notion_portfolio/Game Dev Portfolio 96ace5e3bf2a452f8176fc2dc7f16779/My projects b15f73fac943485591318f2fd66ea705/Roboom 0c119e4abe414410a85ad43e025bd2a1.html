<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Roboom</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="0c119e4a-be41-4410-a85a-d43e025bd2a1" class="page sans"><header><div class="page-header-icon undefined"><img class="icon" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/cover.png"/></div><h1 class="page-title">Roboom</h1><p class="page-description"></p><table class="properties"><tbody><tr class="property-row property-row-text"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/rocket_gray.svg" style="width:14px;height:14px"/></span>Finished</th><td>Jul 2023</td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/gear_gray.svg" style="width:14px;height:14px"/></span>Engine &amp; Language</th><td><span class="selected-value select-value-color-pink">C#</span><span class="selected-value select-value-color-purple">Unity</span></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/briefcase_gray.svg" style="width:14px;height:14px"/></span>Roles</th><td><span class="selected-value select-value-color-blue">Game Dev</span></td></tr><tr class="property-row property-row-multi_select"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/tag_gray.svg" style="width:14px;height:14px"/></span>Tags</th><td><span class="selected-value select-value-color-green">2D</span><span class="selected-value select-value-color-green">RogueLike</span><span class="selected-value select-value-color-green">Top-Down Shooter</span><span class="selected-value select-value-color-yellow">Uni</span></td></tr><tr class="property-row property-row-number"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/groups_gray.svg" style="width:14px;height:14px"/></span>Team Size</th><td>6</td></tr><tr class="property-row property-row-text"><th><span class="icon property-icon"><img src="https://www.notion.so/icons/clock-alternate_gray.svg" style="width:14px;height:14px"/></span>Development Period</th><td>1 Month</td></tr><tr class="property-row property-row-url"><th><span class="icon property-icon"><svg role="graphics-symbol" viewBox="0 0 16 16" style="width:14px;height:14px;display:block;fill:rgba(55, 53, 47, 0.45);flex-shrink:0" class="typesUrl"><path d="M7.69922 10.8945L8.73828 9.84863C7.91797 9.77344 7.34375 9.51367 6.91992 9.08984C5.76465 7.93457 5.76465 6.29395 6.91309 5.14551L9.18262 2.87598C10.3379 1.7207 11.9717 1.7207 13.127 2.87598C14.2891 4.04492 14.2822 5.67188 13.1338 6.82031L11.958 7.99609C12.1768 8.49512 12.2451 9.10352 12.1289 9.62988L14.0908 7.6748C15.7725 6 15.7793 3.62109 14.084 1.92578C12.3887 0.223633 10.0098 0.237305 8.33496 1.91211L5.95605 4.29785C4.28125 5.97266 4.26758 8.35156 5.96289 10.0469C6.36621 10.4434 6.90625 10.7441 7.69922 10.8945ZM8.30078 5.13184L7.26855 6.17773C8.08203 6.25293 8.66309 6.51953 9.08008 6.93652C10.2422 8.09863 10.2422 9.73242 9.08691 10.8809L6.81738 13.1504C5.66211 14.3057 4.03516 14.3057 2.87305 13.1504C1.71094 11.9883 1.71777 10.3545 2.87305 9.20605L4.04199 8.03027C3.83008 7.53125 3.75488 6.92969 3.87109 6.39648L1.91602 8.35156C0.234375 10.0264 0.227539 12.4121 1.92285 14.1074C3.61816 15.8027 5.99707 15.7891 7.67188 14.1143L10.0439 11.7354C11.7256 10.0537 11.7324 7.6748 10.0371 5.98633C9.64062 5.58301 9.10059 5.28223 8.30078 5.13184Z"></path></svg></span>Link</th><td><a href="https://grin2.itch.io/roboom" class="url-value">https://grin2.itch.io/roboom</a></td></tr></tbody></table></header><div class="page-body"><p id="304b4a3f-9058-45be-b2ad-c349bf3eee32" class="">⬅️ Back to the <a href="../../Game%20Dev%20Portfolio%2096ace5e3bf2a452f8176fc2dc7f16779.html"><span class="icon">🚀</span>Game Dev Portfolio</a></p><ul id="31dd04e5-d312-457f-83c0-bad8c2c0845d" class="toggle"><li><details open=""><summary>🧭 <strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Quick Links</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></summary><nav id="a80bfd56-b714-4784-a46c-f43ee679f47e" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f6e22090-131a-492e-9019-c138a7eb49b6">Concept</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8ca4e93b-b715-4787-9238-e430dc0d2f62">Images &amp; Videos</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#a7ab62c9-d84c-4c8f-86be-c0bf9d87b428">Team</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#ed78b8dc-f57d-4b1f-96db-43ae18e4bb8c">Contributions</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6f5ef49b-c473-48aa-9009-78375bd05b64">Process</a></div></nav></details></li></ul><h2 id="f6e22090-131a-492e-9019-c138a7eb49b6" class="block-color-brown_background">Concept</h2><hr id="3f153db9-0dd3-4a76-96a5-823b655649a9"/><div id="7354e731-f757-4a0c-bb3f-bb9e199a398b" class="column-list"><div id="42340bce-bba6-4b2b-afbf-5f84103f769a" style="width:50%" class="column"><figure id="c91ffffc-5982-4ce6-a4e2-5a0de652e08b" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/plakat.png"><img style="width:1459px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/plakat.png"/></a><figcaption>Poster by Mingqi Han (<a href="https://www.linkedin.com/in/mingqi-han-34002824b/">LinkedIn</a>)</figcaption></figure></div><div id="1956080e-11c8-48b7-aaeb-260583eea445" style="width:50%" class="column"><p id="61d18e3c-2995-442e-9cc1-3eff44100c7e" class="">Imagine one day the world just ends. The aliens have finally found us and want our planet. You are a tiny robot specifically built for the purpose of eliminating those aliens. Now it is on you to upgrade your weapons, fight the evil aliens and use your extraordinary acoustic senses to orient yourself in the maze, that are the ruins of the laboratory, that you were built in. Defeat the final boss and escape to help out humanity!<br/><br/><mark class="highlight-brown"><strong>Roboom</strong></mark> is a rogue like dungeon crawler based on &quot;The Binding of Isaac&quot;. It is set in a laboratory, with a unique sound based orientation.<br/>It was made for the course Audio for Games at TUM. We worked on it for a month and made all the assets and music ourselves. The music was integrated using FMOD.<br/></p><p id="b2e25567-77df-438d-a62a-b2ca818d4b5f" class="">We were accepted to present this game at the <a href="https://collab.dvb.bayern/display/TUMinfar/Demo+Day">TUM FAR DemoDay</a> in summer of 2023.</p><p id="42150f1b-1b43-4933-8ad3-1f09ec64df35" class="">
</p></div></div><h2 id="8ca4e93b-b715-4787-9238-e430dc0d2f62" class="block-color-brown_background">Images &amp; Videos</h2><hr id="76a09561-2410-44f2-905d-41ea88300fe0"/><figure id="8ede5b48-4d47-43a2-96ed-01bed1864119"><div class="source"><a href="https://youtu.be/UI96Pdq5D0M">https://youtu.be/UI96Pdq5D0M</a></div><figcaption>The game’s trailer (made by <a href="https://www.linkedin.com/in/maximilianarmuss/">Maximilian Armuß</a>). Follow <a href="https://www.youtube.com/watch?v=UI96Pdq5D0M">this link</a>, if it won’t display.</figcaption></figure><div id="39027a55-ab4f-43b4-8825-4aa75ede8aa9" class="column-list"><div id="f6523213-ba03-4ac5-bbac-edb19a916be3" style="width:50%" class="column"><figure id="1c306f6d-3bcb-488a-b909-ed10728423aa" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Robbom.png"><img style="width:576px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Robbom.png"/></a><figcaption>Enemy room</figcaption></figure></div><div id="717c1e0f-1039-4d0c-a69e-d59e7cf28799" style="width:50%" class="column"><figure id="3cf7a31d-3feb-4f48-9d46-786646945133" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/RobbomBodd.png"><img style="width:576px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/RobbomBodd.png"/></a><figcaption>Boss fight with eye minions</figcaption></figure></div></div><div id="ac42c2a8-130c-482c-914e-4a72d34bff46" class="column-list"><div id="e826e3bf-81dc-4841-8beb-c38790c889d6" style="width:50%" class="column"><figure id="f6f03082-68c9-4476-b96c-482fff5fbd0e" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/startroom.png"><img style="width:576px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/startroom.png"/></a><figcaption>Start room</figcaption></figure></div><div id="3d867033-440e-4bd4-a7b4-2dd6180eb623" style="width:50%" class="column"><figure id="c3305d9a-67a0-4f01-b14f-a439671b5e7a" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/GridScene.png"><img style="width:1610px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/GridScene.png"/></a><figcaption>Scene view of a generated lab map</figcaption></figure></div></div><div id="0bcaeb3f-86e3-402f-8853-dc4c74839fc8" class="column-list"><div id="c45efebe-d014-4762-8a04-72919e63ae38" style="width:50%" class="column"><figure id="a547f2ce-6b0e-4b0d-8c22-21e6081d909b" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/itemroom.png"><img style="width:336px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/itemroom.png"/></a><figcaption>Speed boost item</figcaption></figure></div><div id="c1e7c6af-4765-41c1-ad96-f74f76524b16" style="width:50%" class="column"><figure id="ac83e083-fd99-4df6-b920-202726f18ecb" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/healthroom.png"><img style="width:384px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/healthroom.png"/></a><figcaption>Health item</figcaption></figure></div></div><h2 id="a7ab62c9-d84c-4c8f-86be-c0bf9d87b428" class="block-color-brown_background">Team</h2><hr id="8939b1bc-312a-4785-8483-29581d96aaef"/><ul id="8771cbc1-1374-4c25-a6c4-06f48a85a9f9" class="bulleted-list"><li style="list-style-type:disc">Arthur Öttl: Post processing, items</li></ul><ul id="8f08ac7f-fe47-452a-aa93-c0d66223c3e6" class="bulleted-list"><li style="list-style-type:disc">Kerstin Pfaffinger (me): Room generation, player controller</li></ul><ul id="d62d6c5d-a8e9-4fc3-acb1-fb6282259c4d" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.linkedin.com/in/maximilianarmuss/">Maximilian Armuß</a>: Music, sound effects, FMOD integration</li></ul><ul id="72f34761-3364-4303-903a-3dc24bf4b031" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.linkedin.com/in/michael-vynogradov/">Michael Vynogradov</a>: Enemies, boss fight</li></ul><ul id="c443cbde-69e9-48c0-899f-97122186d702" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.linkedin.com/in/mingqi-han-34002824b/">Mingqi Han</a>: Art, animations</li></ul><ul id="07cc2d60-1c1b-4e2f-af7a-6198451a7503" class="bulleted-list"><li style="list-style-type:disc"><a href="https://www.linkedin.com/in/robin-mayer-314b99243/">Robin Mayer</a>: UI</li></ul><p id="f46b3b94-b8bb-472e-9760-50c5ca5e7046" class="">
</p><h2 id="ed78b8dc-f57d-4b1f-96db-43ae18e4bb8c" class="block-color-brown_background">Contributions</h2><hr id="294c06eb-add2-48a2-8a2e-f476e1ece136"/><ul id="8089c811-ef7a-46eb-8e11-684e77d22e8f" class="bulleted-list"><li style="list-style-type:disc"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1.html"><mark class="highlight-brown"><strong>Player Controller</strong></mark></a><mark class="highlight-brown"><strong>:</strong></mark> The game can be played with both keyboard and controller. I used the new input system to provide implementations for both.</li></ul><ul id="efebac51-167a-443b-a81b-eeaecdc5838a" class="bulleted-list"><li style="list-style-type:disc"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1.html"><strong><mark class="highlight-brown">Room Generation</mark></strong></a><strong><mark class="highlight-brown">:</mark></strong> The rooms should be different in each playthrough. The algorithm chooses a position for the start and boss room and generates the rooms in between according to certain rules.</li></ul><ul id="6f205e21-6d49-4e01-a61f-b874d7f51f4b" class="bulleted-list"><li style="list-style-type:disc"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1.html"><strong><mark class="highlight-brown">Room Switch</mark></strong></a><strong><mark class="highlight-brown">:</mark></strong> Whenever the player goes through a door, they will be positioned correctly in the next room. Additionally, the camera should move in the correct room and stop at the correct position.</li></ul><ul id="9148d625-56f2-45c7-bd0a-e12c162d6228" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-brown"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1.html">Special Rooms</a></mark><strong><mark class="highlight-brown">:</mark></strong> When entering an enemy room, enemies should spawn. At the same time, the doors get blocked by lasers so the player cannot leave the room until they’ve killed all enemies. Similarly, when entering an item room, an item should spawn. Furthermore, when entering the boss room, the boss is spawned at the correct position. After the boss has been defeated, the exit appears. I used object pooling for all spawned objects.</li></ul><ul id="7f0d4b84-e9cd-4d32-a860-d58dabb7f717" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-brown"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1.html">Music Data</a></mark><strong><mark class="highlight-brown">:</mark></strong> I created a small script holding any data and events for implementing the FMOD integration (done by someone else). It could also log the current state in a readable way, which hugely simplified debugging for him.</li></ul><p id="d8b2cf4f-520b-4724-98e4-6e8a774b9db4" class="">
</p><h2 id="6f5ef49b-c473-48aa-9009-78375bd05b64" class="block-color-brown_background">Process</h2><hr id="49bb47fc-07ff-4649-a9ee-c0cfd1c4ce7b"/><p id="fee58e0a-e57d-478f-8b75-08607b3070f4" class=""><mark class="highlight-brown"><strong>Player Controller</strong></mark></p><p id="bc3a9139-0de2-49f3-bc6b-607d9c44bebc" class="">The player controller should fulfill the following requirements: Movement as well as shooting in 2D. I used Unity’s New Input System for abstracting the actual input from the desired action in the game. I added both controller and keyboard bindings.</p><p id="9215f3ae-b685-43cb-ad4d-98e14b1f7ef4" class="">The keyboard input constraints the movement and shooting on 8 axes whereas the joystick of the controller can point in any direction. I figured the movement felt better if the player can walk in any joystick direction. For the shooting, however, I decided to constrain the direction to the 8 axes the keyboard can produce. I wrote a custom processor for that:</p><ul id="9dade622-a00a-4562-83eb-72b4839ca323" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script] </em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>Snap8Processor.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a1c95764-8872-4d29-8724-da45cae202b2" class="code"><code class="language-C#">// for registering processor in input asset 
#if UNITY_EDITOR
    [InitializeOnLoad]
#endif

public class Snap8Processor : InputProcessor&lt;Vector2&gt;
{
    [Tooltip(&quot;Lower values will be snapped to 0, higher ones to +-1&quot;)]
    public readonly float SnapThreshold = 0.5f;
    
    public override Vector2 Process(Vector2 value, InputControl control)
    {
        float snappedX = GetSnapped(value.x);
        float snappedY = GetSnapped(value.y);

        Vector2 snapped = new Vector2(snappedX, snappedY);
        return snapped;
    }

    private  float GetSnapped(float input)
    {
        return Math.Abs(input) &lt; SnapThreshold
            ? 0
            : input.GetSignFactor(); // returns +- 1 depending on sign
    }
    
    
    // register processor
#if UNITY_EDITOR
    static Snap8Processor()
    {
        Initialize();
    }
#endif

    [RuntimeInitializeOnLoadMethod]
    private static void Initialize()
    {
        InputSystem.RegisterProcessor&lt;Snap8Processor&gt;();
    }
}</code></pre></details></li></ul><p id="65b79707-07f7-468b-af63-b9c7fd6a5535" class="">I previously had only used the input system in combination with subscribing to events like <code>inputAction.Player.Jump.performed += MyJumpMethod()</code>. While looking up how to do this correctly, I discovered that there are other methods, too. Eventually, I set it up to “Send Messages” because I found that the most intuitive and simple to do. It essentially creates event methods for the input actions called <code>On&lt;</code><code><em><em><em><em>Action</em></em></em></em></code><code>&gt;</code> and calls them whenever the corresponding action was performed. </p><p id="ea2fe2e6-7cb1-40d5-a2d5-04e22ec10ab0" class="">Initially, I had both the player movement and canon script listening to input, but somehow that caused problems. Either the player or the canon received the inputs at the same time, so I wasn’t able to move and shoot at the same time. This however, was a crucial requirement. So I outsourced the input listening into a separate class, the <code>ControlMapper</code> which simply delegated the calls to the player and the canon. This came in handy later as Robin added a pause menu that also needed to listen to the player input. This is the script:</p><ul id="82abd182-9ab8-43c0-aa6e-5fb2ae9e8608" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em></em></em></em> ControlMapper.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a0b51b85-3c1c-40eb-a4f5-585ee48ed5c5" class="code"><code class="language-C#">public class ControlMapper : MonoBehaviour
{
    [SerializeField] private PauseMenu pauseMenu; // added later by Robin

    private PlayerMovement _playerMovement;
    private PlayerCanon _playerCanon;

    private void Awake()
    {
        _playerMovement = GameObject.FindWithTag(&quot;Player&quot;).GetComponent&lt;PlayerMovement&gt;();
        _playerCanon = GameObject.FindWithTag(&quot;Canon&quot;).GetComponent&lt;PlayerCanon&gt;();
    }

		/// generated event functions called when the respective action is performed

    private void OnMove(InputValue value)
    {
        _playerMovement.Move(value.Get&lt;Vector2&gt;());
    }

    private void OnLook(InputValue value)
    {
        _playerCanon.Look(value.Get&lt;Vector2&gt;());
    }

    private void OnPause()
    {
        pauseMenu.PauseOrContinue();
    }
}</code></pre></details></li></ul><p id="7e070c4d-20a0-4d96-b994-effb73bd8a57" class="">In these scripts I would then apply the input vectors to movement or shooting direction.</p><p id="f0a77b8f-0954-4c7e-816d-571d385a3789" class="">To bring the robot more alive, I flipped its sprite depending on the movement direction so it is always facing to the correct side. The canon is also rotating according to the shooting direction. Here is a short excerpt from the <code>PlayerMovement</code> script along with a shortened version of the <code>PlayerCanon</code> script showing how I implemented movement and sprite flipping:</p><ul id="7e038f96-12e5-4531-b1c5-29710487fc94" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em> PlayerMovement.cs (excerpt)</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="75ccebf7-7f06-46be-97ad-a8f488cf8258" class="code"><code class="language-C#">[SerializeField] private float speed;
private Vector2 _movement;
private Rigidbody2D _rb;
private PlayerCanon _canon;
private float _lastNonZeroX = 1; // player starts looking to the right (= +x)
// more variables [...]

private void FixedUpdate()
{
    _rb.velocity = _movement * speed;
		// audio [...]
}

// called by ControlMapper
public void Move(Vector2 direction)
{
    float inputX = direction.x;

    // Flip model if player moves in opposite direction on x axis
    if (MovesInOppositeDirection(inputX)) FlipPlayerAndCanon();
    if (inputX != 0) _lastNonZeroX = inputX;

    _movement = direction.normalized;
}

private bool MovesInOppositeDirection(float newX)
{
    float oldX = _movement.x;

    // player stops -&gt; no change
    if (newX == 0) return false;

    // check if player starts moving in opposite direction to direction they last moved in
    if (oldX == 0) return newX.HasDifferentSignAs(_lastNonZeroX);

    // else just check if player turns while moving
    return newX.HasDifferentSignAs(oldX);
}

private void FlipPlayerAndCanon()
{
    transform.FlipModelHorizontally();
    _canon.Flip();
}</code></pre></details></li></ul><ul id="b8d493f4-0475-4465-ae88-0491f5a66109" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em></em></em></em></em></em></em></em> PlayerCanon.cs (shortened)</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b7ebde59-935b-40da-89dd-77d5b46430a6" class="code"><code class="language-C#">public class PlayerCanon : MonoBehaviour
{
    [SerializeField] private float cooldown = .4f;

    private BulletPool _pool;
    private Vector2 _direction;

    private bool _doShoot;
    private bool _coroutineRunning;
    private bool _isFlipped;

    public static event Action&lt;SfxInstanceNames&gt; OnPlayerShot; // by Maxi

    private void Awake()
    {
        _pool = GameObject.FindWithTag(&quot;BulletPool&quot;).GetComponent&lt;BulletPool&gt;();

        // canon is oriented to the right initially
        _direction = Vector2.right;

        _doShoot = false;
        _coroutineRunning = false;
        _isFlipped = false;
    }

    private void FixedUpdate()
    {
        var dir = _isFlipped
            ? _direction.FlipDiagonally()
            : _direction;
        var lookAtPos = CalculateLookAtTarget(dir);
				
				// custom LookAt!! -&gt; See ExtensionMethods\Workarounds2D
        transform.LookAt2D(lookAtPos);
    }


		// called by ControlMapper
    public void Look(Vector2 direction)
    {
        _direction = direction.normalized;

        if (_direction == Vector2.zero) StopFire();
        else StartFire();
    }

    private Vector3 CalculateLookAtTarget(Vector2 lookingDirection)
    {
        return transform.position + lookingDirection;
    }


    private void StartFire()
    {
        if (_coroutineRunning) return;

        _doShoot = true;
        StartCoroutine(nameof(ShootRepeatedly));
    }

    private void StopFire()
    {
        _doShoot = false;
        _coroutineRunning = false;
        StopAllCoroutines();
    }

    public void Flip()
    {
        _isFlipped = !_isFlipped;
    }


    private IEnumerator ShootRepeatedly()
    {
        _coroutineRunning = true;

        while (_doShoot)
        {
            Shoot();
            yield return new WaitForSeconds(cooldown);
        }

        _coroutineRunning = false;
        yield return null;
    }

    private void Shoot()
    {
				// for sound effect
        OnPlayerShot?.Invoke(SfxInstanceNames.PlayerShot);
        _pool.ShootBullet(_direction);
    }</code></pre></details></li></ul><p id="7308e476-0da2-4312-85ee-42509e6b7e97" class="">As the built-in <code>LookAt()</code> method doesn’t really work in 2D, I wrote my own based on some math I found on the Internet. I like to make functionality like this available to everyone in the team, which is why I extracted it into a separate script holding some extension methods. I did so with any quality of life change I did:</p><figure id="89cc6f4b-38a6-4d95-977e-71ff3b103488" class="image" style="text-align:left"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled.png"><img style="width:264px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled.png"/></a></figure><p id="a5f5bf0b-5ff6-4b35-9a20-7b4d6ac13775" class="">The flipping method, for example, looked like this:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ba59b9c4-23fe-4197-90f4-dff8ec076477" class="code"><code class="language-C#">public static class Transforms
{
    public static void FlipModelHorizontally(this Transform transform)
    {
        var scale = transform.localScale;
        transform.localScale = new Vector3(-scale.x, scale.y, scale.z);
    }
		
		// [...]
}</code></pre><p id="ac023bef-e88e-4c31-ad83-5e5f3b9c32d3" class="">It also makes the code cleaner and easier to understand, which is a handy additional benefit.</p><p id="e8d0c7bc-42ee-4a6f-a378-2b280e6bbb96" class="">Also note that I used <code>FindWithTag</code> for the <code>BulletPool</code> instead of creating another <code>SerializedField</code>. I did this because I wanted to make the player as easy to use as possible. I’m always confused when I include another person’s feature in my scene and it throws <code>NullReferences</code> because some variables are not assigned and I don’t quite know which objects to drag into the fields. And as the player is a quite essential part of the game, I wanted it to work as smoothly as possible without a huge setup.</p><p id="8150ccfb-4b97-44ec-9091-8584e5f8b1ea" class="">You can see from the name of the <code>ShootRepeatedly()</code> coroutine that I initially planned to only allow for holding down the shoot button and shooting out bullets in a fixed time interval. During testing, however, I found that the player could still spam the shot button and fire bullets in a very high rate. But I enjoyed it so much I decided to keep it. We also attended some playtesting events and people really seemed to love it, too. To avoid any performance issues stemming from the player hammering the shoot button and therefore instantiating lots of objects within a short period of time, I employed the object pool pattern to reuse bullets. I tested how many bullets I could shoot from one side of a room to the opposing wall to determine how many bullets the pool must hold to avoid running out of bullets.</p><ul id="df346764-5a1b-40cf-a04e-72a252194843" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em> BulletPool.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6eeacd47-fc82-4731-bced-06f72720950d" class="code"><code class="language-C#">public class BulletPool : MonoBehaviour
{
    [SerializeField] private float speed = 3;
    [SerializeField] private FMODUnity.EventReference shotEvent;

    // init here otherwise _bullets.Add() will throw NullReference
    private readonly List&lt;Bullet&gt; _bullets = new();
    private Vector2 _poolPos;
    private Transform _canon;
    
    private EventInstance _shotEvent; // added by Maxi

    private void Awake()
    {
        _poolPos = transform.position;
        _canon = GameObject.FindWithTag(&quot;Canon&quot;).transform;
        _shotEvent = FMODUnity.RuntimeManager.CreateInstance(shotEvent);
        InitBullets();
    }

    private void InitBullets()
    {
        for (int i = 0; i &lt; transform.childCount; i++)
        {
            var child = transform.GetChild(i);
            var bulletComponent = child.GetComponent&lt;Bullet&gt;();
            _bullets.Add(bulletComponent);
        }
    }

    public void ResetBullet(Bullet bullet)
    {
        _bullets.Add(bullet);
        bullet.transform.position = _poolPos.ToVec3();
        bullet.Disable();
    }
    

    public void ShootBullet(Vector2 direction)
    {
        var bullet = _bullets.Pop();

        var canonPos = _canon.position;
        bullet.transform.position = canonPos;
        bullet.transform.rotation = _canon.localRotation;
        
        bullet.Shoot(direction, speed);

        _shotEvent.start(); // by Maxi
    }

		// by Maxi
    private void OnDestroy()
    {
        _shotEvent.stop(STOP_MODE.ALLOWFADEOUT);
        _shotEvent.release();
    }
}</code></pre></details></li></ul><p id="5be3d4d2-f07d-4b01-8bed-f8683bfb3994" class="">This is how I always structure my pool objects. I create an array holding all the pooled objects. The pool object is parent of all objects in the pool and the array is initialized with all children on <code>Awake()</code>. The pool then provides a <code>public</code> method for spawning and initializing one of the objects, ready to use for other scripts. Moreover, it has another <code>public</code> method that can be called by any of the pooled objects itself to register them back into the pool. So instead of <code>Destroy()</code>ing the bullet as soon as it hits a wall or an enemy, I reset itself in the pool for later use. This is what the bullet does if it collides:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e9b1dfdb-886f-48b7-980a-49d118778ee9" class="code"><code class="language-C#">private BulletPool _pool;
private readonly List&lt;string&gt; _tagsToCollide = new() {&quot;Enemy&quot;, &quot;Obstacle&quot;, &quot;Door&quot;, &quot;Boss&quot;};

private void OnCollisionEnter2D(Collision2D other)
{
    if (!other.HasOneOfTags(_tagsToCollide)) return;
    _pool.ResetBullet(this);
}</code></pre><p id="64cddc59-a8dc-417b-a3c1-0417713e127c" class="">Note that <code>HasOneOfTags()</code> is another custom extension method. This way, I could easily add tags to the list without the need of adding another <code>|| other.CompareTag(&quot;newTag&quot;)</code> to a chain of conditions.</p><p id="d5d1891b-dd22-4187-98ad-355988d56660" class="">
</p><p id="1dc6c1ac-6670-483b-b5bd-fd174d76f548" class="">
</p><p id="2f37df52-5ffd-42bc-bfc8-d96563081ec1" class=""><mark class="highlight-brown"><strong>Room Generation</strong></mark></p><p id="9d9c1030-c6f5-4a6d-9f01-d3cd10783a51" class="">For simplicity, we decided that the map would always have the same layout and only the room contents are generated randomly prior to each playthrough.</p><p id="f551137d-5231-4614-be30-b293ff43a9e7" class="">The rooms are laid out in a 5x5 grid. The start room is generated somewhere on the left side of that grid.</p><p id="621f3882-cd10-480a-ac41-a0b6cf0aedce" class="">Before I started, I made a few sketches in OneNote to plan everything out. I tend to make bullet points for the actual algorithm as well. This way I can structure my thoughts without having to adhere to any syntax. I can also focus on the big picture, ignoring the implementation details:</p><div id="d562de78-e4ee-4e92-b440-2960eefb7944" class="column-list"><div id="3a2d73d9-ff9d-4899-9c55-9a7e85c41f24" style="width:50%" class="column"><figure id="a34393e0-f9df-4d5e-8e8c-0fe73195acb8" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%201.png"><img style="width:864px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%201.png"/></a></figure></div><div id="98a66257-f4e4-49f6-9101-5ccf8c701e17" style="width:50%" class="column"><figure id="d70fc8af-1ff1-4dae-b61c-f16b13ead783" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%202.png"><img style="width:1215px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%202.png"/></a></figure></div></div><p id="74ba8223-d18a-48f0-b1ff-9d4aee038703" class="">For the grid, I created a class modelling a 2D array, that is internally stored as a one-dimensional one. I added methods that convert between 1D and 2D indices and provided some methods the room generation would need, i.e. getting all adjacent rooms given a certain index. I also created an <code>enum</code> for the types of rooms the map should contain. </p><p id="c1e721ce-2c96-4ef8-a000-79fde66ca426" class="">Now the grid needed to be filled with these types. I went through several iterations trying out which of them yields the most enjoyable, fair and balanced layout for the player. I first defined some general rules that any generation must fulfill:</p><ul id="da9a4a95-c524-49b1-b539-0c587d4ab838" class="bulleted-list"><li style="list-style-type:disc">There should be an empty room next to the start room.</li></ul><ul id="ea581f34-8881-496a-81ac-d25505c450d0" class="bulleted-list"><li style="list-style-type:disc">The boss room should be at least 2 rooms away from the start room. This was not only necessary to make the game balanced and interesting, but also created some space for the music to intensify towards the boss room.</li></ul><ul id="efd94eec-e79f-4627-9fc6-96809f483c67" class="bulleted-list"><li style="list-style-type:disc">There should be a maximum number of adjacent empty and enemy rooms. Adjacent includes the rooms diagonally adjacent to the current one.</li></ul><ul id="865ef5af-541e-48a6-8fe9-ed5dc16244ed" class="bulleted-list"><li style="list-style-type:disc">The item rooms should be spread out.</li></ul><p id="f106836e-d174-497d-98b2-f0bb26397729" class="">You can see from the <a href="Roboom%200c119e4abe414410a85ad43e025bd2a1.html">drawings</a> I made, that I initially planned to start by placing the “special” rooms, meaning any room except for empty rooms. I would then fill the remaining fields with empty rooms. The first algorithm, however, traversed the room grid linearly (meaning column by column). I wrote a function taking a position in the grid, computing the possible room types for that room according to the rules defined above and picking a random option.</p><p id="82ba8b66-c554-4af8-8878-cfa200c3d23d" class="">However, I wasn’t quite happy with the results. The item rooms weren’t as spread out as I wanted and there often were clusters of enemy or empty rooms, so the whole map lacked some balance and had no organic nature.</p><p id="8b824922-ac23-477c-9fc0-542dd3ae2f9b" class="">I traced it back to a major problem: The generator traversed the grid columns from left to right, meaning half of the adjacent rooms weren’t filled when a room type was chosen. That in turn meant that my thresholds for the maximum size of room clusters would be reached seldom. That was why it generated this big patches of enemy or empty rooms. Lowering the threshold didn’t work either, because now there were too few enemy rooms making the map very boring to explore and play.</p><p id="c544d6e0-e5f1-46d5-850c-b5bb786c7d52" class="">To counteract the column problem, I tried to skip columns when generating and filling those later. For the 5x5 grid, I would first generate columns 1, 3 and 5. Then I would fill 2 and 4 respecting the room limits I set earlier. This really improved both item spread and clustering issues.</p><p id="481b790e-46ef-44d4-af35-f75f72030339" class="">On the Unity side, I had some issues with the map objects itself. First, each room type was different both aesthetically and functionally. They all had different colors to give immediate visual cues to the player when entering. Enemy and boss rooms needed to have lasers on the doors while the fight was happening so that the player couldn’t just leave the room. Additionally, the rooms should be connected correctly, so there should only be doors where the player can actually leave the room to get to another one. First, I thought I would need a distinct prefab for each combination of room type and door layout and spawn them in correctly via script.</p><p id="70cf4b05-1075-4d93-837d-0a1c1f6d89dd" class="">Especially the “color the walls according to the room type” problem had me bothered for some time Together with the issue that instantiating prefabs containing tile sets didn’t seem to work. So I thought I had to place 3-4 versions of each combination somewhere in the scene and move them to the correct place if they were generated.</p><p id="9b5c64e5-c68b-4d48-a0b5-933e7e98dd12" class="">But then it clicked. First, I found out, that I had to instantiate the room tilesets as children of an object with the <code>Tileset</code> component in order to make the tileset being displayed correctly. For the walls and doors, I felt like it would be the easiest approach to have the fixed layout in the scene and only instantiate the room contents. Eventually, I created a semi-transparent overlay frame that covered up the walls. I attached the frames to each room content prefab and adjusted the color. This way, I could reduce the number of prefabs to 6 (= number of room types).</p><div id="35730756-40a4-4c03-81cf-665e3b029a77" class="column-list"><div id="2ac0ddb7-0d7b-4bd7-a19d-a749eed29b3d" style="width:50%" class="column"><figure id="c9a9b338-4e3a-4050-8bfc-5f8af30b67c7" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%203.png"><img style="width:816px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%203.png"/></a><figcaption>Enemy room “content” prefab with transparent overlay</figcaption></figure></div><div id="ba8f81f4-9669-4f72-ad9b-1240df71d4d2" style="width:50%" class="column"><figure id="6bb6c564-4ff5-404f-940f-36722707e090" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%204.png"><img style="width:846px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%204.png"/></a><figcaption>Fixed wall layout in the scene</figcaption></figure></div></div><p id="77767bf4-882d-44b9-9a6b-7a39fbcb8bf2" class="">It also simplified the implementation of the doors, see <a href="Roboom%200c119e4abe414410a85ad43e025bd2a1.html"><strong>Room Switch</strong></a><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong> </strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong>for that.</p><p id="8ee4c1c1-ad56-482e-a6e1-a04b4efd323f" class="">Here are the most important parts of the script: </p><ul id="3b054c05-2036-474c-897f-9c038b5c23c4" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script] </em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>RoomGeneration.cs (shortened)</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a252d65d-e782-480d-87d4-1a6e74cfbb73" class="code"><code class="language-C#">public class RoomGenerator : MonoBehavior
{
		[Header(&quot;Dimensions&quot;)]
    [SerializeField] private Vector2Int roomDimensionsWithoutWalls = new(16, 8);
    [SerializeField] private Vector2Int mapDimensions = new(5, 5);

		// some prefabs for Rooms and Walls [...]

		// map is made out of tiles, which only display correctly when child of a tileset object
		[Header(&quot;Grid&quot;)]
    [SerializeField] private Transform grid;

		// other private variables [...]
		// events and getters [...]

		// use start and not awake so that player has time to sub to events
    private void Start()
    {
        InitVariables();
        ExcludeTypeFromGenerating(RoomType.Invalid);
        PositionStartRoom();
        CreateDoorToStartRoomInAdjacentRoom();
        // depend on start room position 
        InitNoItemPositions();
        SpawnBoss();
        FillGrid();
    }

		/// START ROOM
		private void PositionStartRoom()
    {
        _startRoomY = ChooseStartRoomY();

        Vector3Int startRoomPos = GetRoomPosAt(StartRoomX, _startRoomY).ToVec3();
        SpawnRoomAtGridPos(StartRoomX, _startRoomY, RoomType.Start);

        OnGeneratedStartRoom?.Invoke(startRoomPos);

        // start room is now generated, prevent from being spawned in grid
        ExcludeTypeFromGenerating(RoomType.Start);
    }

    private int ChooseStartRoomY()
    {
        // range max is exclusive, so just use height and not height-1
        return Random.Range(0, _gridHeight);
    }

		private void CreateDoorToStartRoomInAdjacentRoom()
    {
        // remove neighboring room as its walls are blocking the way back to the start room
        Transform adjacentRoom = firstColumnWalls[_startRoomY];
        Destroy(adjacentRoom.gameObject);

        // middle is most likely (has doors on all 4 sides)
        Transform fittingRoom = middleWalls;
        
        if (_startRoomY == 0) fittingRoom = northernWalls;
        if (_startRoomY == _gridWidth - 1) fittingRoom = southernWalls;

        // grid as parent is extremely important for tiles to work properly!
        Instantiate(fittingRoom, adjacentRoom.localPosition, Quaternion.identity, grid);
    }

		
		private void SpawnBoss()
    {
        int bossX = Random.Range(0, _gridWidth);
        int bossY = ChooseBossY(bossX);

        _bossPosition = new Vector2Int(bossX, bossY);
        SpawnRoomAtGridPos(bossX, bossY, RoomType.Boss);
        ExcludeTypeFromGenerating(RoomType.Boss);

        OnGeneratedBossRoom?.Invoke(_bossPosition.ToVec3());
    }

		// [...]

		private void FillGrid()
    {
        for (int i = 0; i &lt; _gridWidth; i++)
        {
            int x = _columnIndices[i];

            for (int y = 0; y &lt; _gridHeight; y++)
            {
								// there is already a room generated at this position
                if (IsBossPosition(x, y)) continue;

                RoomType roomType = GetOptimalRoomFor(x, y);
                SpawnRoomAtGridPos(x, y, roomType);

                // make sure generation complies with limits of special rooms
                ExcludeRoomTypeIfNecessary(roomType);
            }
        }
    }

		// [...]

		private RoomType GetOptimalRoomFor(int x, int y)
	  {
	      // room next to start room should be empty
	      if (IsNextToStartRoom(x, y))
	          return RoomType.Empty;
	      
	      // if all are possible, choose a random option that has not reached its limit yet
	      if (!TooMuchOfMyRoomTypeInAdjacentRooms(x, y, RoomType.Health) &amp;&amp;
	          !TooMuchOfMyRoomTypeInAdjacentRooms(x, y, RoomType.Item) &amp;&amp;
	          !TooMuchOfMyRoomTypeInAdjacentRooms(x, y, RoomType.Enemy) &amp;&amp;
	          !TooMuchOfMyRoomTypeInAdjacentRooms(x, y, RoomType.Empty))
	          return RoomTypeWrapper.GetRandomRoomTypeExcept(_unwantedRoomTypes);
	
	      // check if item or health is possible -&gt; genertate them with higher priority to spread them out
	      if (!TooMuchOfMyRoomTypeInAdjacentRooms(x, y, RoomType.Health) &amp;&amp;
	          !ItemCannotSpawnAt(x, y) &amp;&amp;
	          OneOfItemAndHealthIsWanted())
	      {
	          if (BothItemAndHealthAreWanted())
	              return Randomization.RandomlyTrueOrFalse()
	                  ? RoomType.Health
	                  : RoomType.Item;
	
	          return _unwantedRoomTypes.Contains(RoomType.Item)
	              ? RoomType.Health
	              : RoomType.Item;
	      }
	
	      // decide between enemy and empty: choose the type with less adjacent rooms
	      if (!TooMuchOfMyRoomTypeInAdjacentRooms(x, y, RoomType.Enemy) &amp;&amp;
	          TooMuchOfMyRoomTypeInAdjacentRooms(x, y, RoomType.Empty))
	          return RoomType.Enemy;
	
	      if (TooMuchOfMyRoomTypeInAdjacentRooms(x, y, RoomType.Enemy) &amp;&amp;
	          !TooMuchOfMyRoomTypeInAdjacentRooms(x, y, RoomType.Empty))
	          return RoomType.Empty;
	
	      // if #enemy rooms == #empty rooms choose randomly
	      return Randomization.RandomlyTrueOrFalse()
	          ? RoomType.Enemy
	          : RoomType.Empty;
	  }

		// [...]

}</code></pre></details></li></ul><p id="72330b18-42cf-455d-82d6-e3e7ee0c24c4" class=""> </p><p id="0eac4f48-53ae-47da-a9b2-f94cc271f258" class="">
</p><p id="25889e1e-fc02-4d86-8e7a-5ae36c625839" class=""><mark class="highlight-brown"><strong>Room Switch</strong></mark></p><p id="29ca993c-3082-4280-bf15-d2a99a3438dc" class="">In theory, the player could simply walk over the door tiles, as all of the rooms are connected with each other on the same map. Inspired by The Binding of Isaac, we opted for having a static camera that switches to the correct room when the player enters any door.</p><p id="bd1c536f-1ff3-4b2d-8ab5-1dfc69b6c5da" class="">That meant, I would need a camera that stayed in a fixed position capturing the whole room and moving to the correct position in the room the player goes to.</p><p id="33144c20-a8fc-46fc-a18e-fb17ea6d2f8a" class="">As the position of the start room is random, too, the initial position of the camera could only be determined after that. I already had an event <code>OnStartRoomGenerated</code> to spawn the player in the start room, so I subscribed to that in the <code>RoomCamera</code>, too.</p><p id="984e0204-d4d2-4711-b81c-1dfb01d8ba4f" class="">The room switch is an essential cue in the game, so I created an event for that, too. It is needed for music, camera and both player movement and health.Because I had to tell the subscribers in which direction the room switch is going to happen, I wrote a custom delegate to be able to pass the <code>Direction</code> and positional change:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="12bc487e-f459-4970-90d3-f43f6e94fe16" class="code"><code class="language-C#">public delegate void PositionalAndDirectionalAction(Vector3 posChange, Direction direction);
public static event PositionalAndDirectionalAction OnRoomSwitch;
</code></pre><p id="467af722-7cd8-4ffa-83fa-42c8da0cdfa9" class=""> I placed trigger boxes in front of each door in the fixed wall layout, that would fire that event:</p><figure id="570da0be-3217-4d5e-9caf-a55ecbff6f0b" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%205.png"><img style="width:432px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%205.png"/></a><figcaption>Door trigger colliders</figcaption></figure><p id="73f9ee44-46b2-4efc-8c1e-323a40131354" class="">While testing, I noticed some things that needed to be changed:</p><ul id="f8b7f0ec-81b6-4dde-b37a-233312088588" class="bulleted-list"><li style="list-style-type:disc">The doors should only trigger when the player enters. That pesky ufo moved the camera around way to often…</li></ul><ul id="5c7b1cc3-610e-478d-b903-ba4d10057286" class="bulleted-list"><li style="list-style-type:disc">The doors should only trigger if the player moves towards them. Initially, it also switched when I was just walking up along the door.</li></ul><ul id="8aeb380a-7db8-42ab-aa1d-3d3e425c23f6" class="bulleted-list"><li style="list-style-type:disc">The triggers needed to be disabled during a fight. Otherwise, the player could run away from the enemies.</li></ul><p id="92e0ce23-d9f0-4e8c-b307-3453c2baa07d" class="">The first one was solved with a simple tag check. For the second one, I needed to do a bit of testing to guarantee that diagonal movements will also trigger, but only if the angle towards the door was small enough. I eventually chose a 45° angle.</p><p id="b2d279e2-7cef-433a-9909-921ce966de14" class="">For the third one, I simply added a <code>boolean</code> telling whether the trigger was active or not. The tough part was how to figure out when a fight was about to happen. My first approach was to add an event for both start and end of the fight and change the state of the trigger based on those events. We re-added the event later for music, but for the triggers, I found another solution. It came in handy that we decided to add a visual clue indicating that the exits are blocked. To fit the lab theme, we made the doors be blocked by deadly lasers:</p><div id="ff698f1f-2174-41f1-b5d6-371173051919" class="column-list"><div id="b23a269c-8090-4e10-b8e8-4be4576178e3" style="width:50%" class="column"><figure id="b5e37fd3-d3e5-429c-b42e-e5a98e26cc74" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%206.png"><img style="width:556px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%206.png"/></a><figcaption>Open door in enemy or boss room.</figcaption></figure></div><div id="3c3c1dbd-0216-4d76-9c9c-13eb981065fa" style="width:50%" class="column"><figure id="b421c109-8ec9-4331-8a31-783dab530eea" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%207.png"><img style="width:553px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%207.png"/></a><figcaption>Door blocked by lasers.</figcaption></figure><p id="48ed3204-5d4c-421a-ae99-307ae9e9afc5" class="">
</p></div></div><p id="80c84040-4bcf-4862-bad8-97c3523ef719" class="">The <code>DoorTrigger</code>s had colliders anyways, so I tried checking if a laser object was colliding and adjusting the activated state based on that. The laser GameObjects are activated and deactivated so <code>OnTriggerEnter</code> and <code>Exit</code> are both called.</p><p id="34956959-1275-4263-816a-d2b866a70938" class="">As the rooms’ walls were blocking the player, I additionally needed to add to the player’s position in the direction of the room switch to move it to the new room. I made the thickness of the walls adjustable to make the code more flexible. In the <code>PlayerMovement</code> script, I added this:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="44746f30-8188-42e1-abdd-6086b6155047" class="code"><code class="language-C#">private void MoveIntoOtherRoom(Vector3 absolutePosChange, Direction _)
{
		// get direction of movement
    var normalized = absolutePosChange.normalized;
		// account for walls
    var scaledWithWallWidth = normalized * SwitchOffset;
		// teleport player to next room
    transform.position += scaledWithWallWidth;
}</code></pre><p id="f47b75be-cbd0-4557-8341-82d26b5783dc" class="">I had to configure every door with its correct direction, and I often got errors or weird camera movements because the doors weren’t set up correctly. To help me with finding the door that was missing, I wrote a little method detecting if the direction (which is a simple enum containing all compass directions) was a valid one and if not, print the name of the door. That sped up searching for the correct object immensely. Here you can see the full <code>DoorTrigger</code> implementation:</p><ul id="37a80cb7-14f6-4fba-abbe-41525125232b" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em>[Script] </em></em></em></em></em></em></em></em></em>DoorTrigger.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a8d54ff1-3ded-49d8-846c-2ae10dad41b0" class="code"><code class="language-C#">public class DoorTrigger : MonoBehaviour
{
    public delegate void PositionalAndDirectionalAction(Vector3 posChange, Direction direction);
    public static event PositionalAndDirectionalAction OnRoomSwitch;

    [SerializeField] private Direction direction;
    
    // thickness of the walls
    private static readonly Vector2Int WallOffset = new(1, 1);
    private RoomGenerator _roomGenerator;
    private PlayerMovement _playerMovement;
    private Vector3 _posChange;
    
    // triggers are deactivated during a fight
    private bool _activated;
    

    #region Init

    private void Awake()
    {
        _roomGenerator = GameObject.FindWithTag(&quot;RoomGenerator&quot;).GetComponent&lt;RoomGenerator&gt;();
        _playerMovement = GameObject.FindWithTag(&quot;Player&quot;).GetComponent&lt;PlayerMovement&gt;();
        
        var roomDimensions = _roomGenerator.GetRoomDimensions();

				// for a door, the change is always the same, so precompute it
        _posChange = CalculatePosChange(roomDimensions);
        _activated = true;
				
				// helper for correct setup
        ErrorPrintIfDirectionInputIsNotSuitable();
    }


    private Vector3 CalculatePosChange(Vector2Int roomDimensions)
    {
        var roomDimensionsWithWalls = roomDimensions + 2 * WallOffset;

        Vector2Int dirVector = DirectionMapper.GetVectorForDirection(direction);
        // scale with dimensions as direction mapper returns normed vector
        dirVector *= roomDimensionsWithWalls;

        return dirVector.ToVec3();
    }

    private void ErrorPrintIfDirectionInputIsNotSuitable()
    {
        switch (direction)
        {
            case Direction.Invalid:
                Debug.LogError($&quot;Door direction of {name} was not set!&quot;);
                break;
            case Direction.NorthEast or Direction.NorthWest or Direction.SouthWest or Direction.SouthEast:
                Debug.LogError($&quot;Door direction of {name} is diagonal: {direction}! It is invalid, please change it.&quot;);
                break;
        }
    }

    #endregion

    #region Trigger
		
		// use stay because it should work if trigger gets activated while player standing in it
    private void OnTriggerStay2D(Collider2D other)
    {
				// don&#x27;t let player escape during a fight
        if (!_activated) return;

        if (other.IsPlayer())
        {
						// don&#x27;t switch if player just walks along the walls
            if (!MovesInCorrectDirection()) return;
            OnRoomSwitch?.Invoke(_posChange, direction);
        }
				else if (other.HasTag(&quot;Laser&quot;))
				{
						Deactivate();
				}
    }

    private void OnTriggerExit2D(Collider2D other)
    {
        if (other.HasTag(&quot;Laser&quot;)) Activate();
    }

    private bool MovesInCorrectDirection()
    {
        // in 2D forward is right
        var forward = _playerMovement.GetMovement();

        return direction switch
        {
            Direction.North =&gt; forward.y &gt; 0,
            Direction.East =&gt; forward.x &gt; 0,
            Direction.South =&gt; forward.y &lt; 0,
            Direction.West =&gt; forward.x &lt; 0,
            _ =&gt; false
        };
    }

    private void Activate()
    {
        _activated = true;
    }

    private void Deactivate()
    {
        _activated = false;
    }

    #endregion
}</code></pre></details></li></ul><p id="81bd1ebb-fb55-4647-a5df-1449856818ef" class="">The others wanted to have a transition animation, so I let the camera <code>MoveTowards</code> the next room instead of setting the position directly. I had some problems with the camera not showing the map. I figured it was caused by its <code>z</code> coordinate being to close to the rooms. I also needed some way to fix the camera’s distance, so it would always perfectly capture a single room. To achieve this, I move the camera around in the scene view until everything was in the picture correctly. I stored its <code>z</code> position in a variable and only changed <code>x</code> and <code>y</code> during a room switch. The two are calculated correctly by the <code>DoorTriggers</code> already, so I could blindly apply the change to the camera’s position. Here is the full implementation:</p><ul id="98be674b-ab9e-4292-9614-b9453d9cb811" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em>[Script] </em></em></em></em></em></em></em>RoomCamera.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4f5e6516-6c31-4f03-82a5-0e6a8a105438" class="code"><code class="language-C#">public class RoomCamera : MonoBehaviour
{
    [SerializeField] private float switchSpeed = 2f;
    
    // as we are in 2D, this is important for visibility
    private float _posZ;
    private bool _doSwitch;
    private Vector3 _currentTarget;
    
    private void Awake()
    {
        RoomGenerator.OnGeneratedStartRoom += PositionCam;
        DoorTrigger.OnRoomSwitch += SwitchCam;

        _posZ = transform.position.z;
        _doSwitch = false;
    }

    private void FixedUpdate()
    {
        if (!_doSwitch) return;

        transform.position = Vector3.MoveTowards(transform.position, _currentTarget, switchSpeed);
        if (transform.position != _currentTarget) return;
        
        _doSwitch = false;
        _currentTarget = transform.position;
    }

		// posChange is calculated wrt room dimensions by door :)
    private void SwitchCam(Vector3 posChange, Direction _)
    {
        _doSwitch = true;
        _currentTarget = transform.position + posChange;
    }

    private void PositionCam(Vector3 pos)
    {
				// without this, the camera sometimes wouldn&#x27;t capture the start room
        pos.z = _posZ;
        transform.position = pos;
    }

    private void OnDestroy()
    {
        RoomGenerator.OnGeneratedStartRoom -= PositionCam;
        DoorTrigger.OnRoomSwitch -= SwitchCam;
    }</code></pre></details></li></ul><p id="5f3c73c0-44dd-4f7f-9134-36e93bebd657" class="">
</p><p id="60363e34-1dbd-49ce-9fba-20e6a9740ac4" class="">
</p><p id="6c67b56e-4415-4620-a109-008f5879f560" class=""><mark class="highlight-brown"><strong>Special Rooms</strong></mark></p><p id="3e4bd573-3bec-4d04-b347-2e55610e8d93" class="">Initially, I treated all rooms equally. But over time, I realized that I will need to add some characteristic functionality to some of the rooms. “Some” meant any room type except for the empty one. As with all features, I needed several attempts to arrive at the subjectively best solution. Let’s start with the enemy room. The rules were as follows:</p><p id="7ce2a5eb-d860-4da0-a383-0af01f13e11c" class="">When the player enters…</p><ul id="0609a2d6-674c-460b-a6fc-3478ddb46858" class="bulleted-list"><li style="list-style-type:disc">spawn in the enemies,</li></ul><ul id="2ddc731f-8112-4182-b75d-fc3346870a14" class="bulleted-list"><li style="list-style-type:disc">play the enemy music,</li></ul><ul id="f0b60784-bb6f-4095-862b-647ef817c4af" class="bulleted-list"><li style="list-style-type:disc">block the door with deadly lasers when the enemies are spawned.</li></ul><p id="006d8902-d945-48ec-9ce0-a0bf62dc8b38" class="">Playing the music was again handled using events fired if the current room happened to be an enemy room. Same for the boss room.</p><p id="9cbdf87f-5997-4ebd-866a-e555a45f7c41" class="">The “when the player enters, spawn XY” part was needed for all of the other rooms as well, so I added a <code>Spawner</code> class which all the others could inherit from:</p><ul id="7b91c40c-1523-459f-a421-11a70002efb1" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em> Spawner.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="48768ce3-1db1-439f-98c5-cb3bbc82e323" class="code"><code class="language-C#">public abstract class Spawner : MonoBehaviour
{
    protected const int NumberOfDoors = 4;
    private readonly Transform[] _colliders = new Transform[NumberOfDoors];


    private void Awake()
    {
        InitColliders();
    }

    private void InitColliders()
    {
        for (int i = 0; i &lt; NumberOfDoors; i++)
        {
            _colliders[i] = transform.GetChild(i);
        }
    }

		// called by SpawnCollider.cs
    public void Spawn()
    {
        SpawnThing();
        DestroyColliders();
    }

    protected abstract void SpawnThing();

    private void DestroyColliders()
    {
        for (int i = NumberOfDoors - 1; i &gt;= 0; i--)
        {
            Destroy(_colliders[i].gameObject);
        }
    }</code></pre></details></li></ul><p id="361d1124-2174-47c2-804c-88e9009804c2" class="">Together with some <code>SpawnCollider</code>s that trigger spawning when the player enters:</p><ul id="287d1156-3517-4850-a210-a51bc29d9504" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em> SpawnCollider.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d309f587-4c69-4c05-aa5a-a6d28ec1201d" class="code"><code class="language-C#">public class SpawnCollider : MonoBehaviour
{
    protected Spawner Spawner;

    private void Awake()
    {
        Spawner = GetComponentInParent&lt;Spawner&gt;();
    }

    protected virtual void OnTriggerEnter2D(Collider2D other)
    {
        if (!other.IsPlayer()) return;
        Spawner.Spawn();
    }
}</code></pre></details></li></ul><p id="0beb4929-0591-4cd1-868a-967c58c79e4e" class="">They are placed in front of the doors. I realized that the player can somehow miss them when moving away from the door very fast, so I made them big enough to catch the player in any case:</p><figure id="21bf2d72-23bf-4857-bb9a-4364fcba2b89" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%208.png"><img style="width:624px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%208.png"/></a><figcaption>Spawn colliders in an enemy room prefab</figcaption></figure><p id="b0fff04b-2e3d-4fdc-b2b0-efe5052f1a9b" class="">Note that all colliders are destroyed after the player entered them, so the spawning happens only the first time the player enters. We found that to be the most reasonable for both items and enemies, and of course also for the boss.</p><p id="a5d8522f-39e6-46d1-ad24-901127fc6e49" class="">Over time, I did extract another class <code>LaserRoomSpawner</code>, which inherits from <code>Spawner</code> but is the super class of both <code>EnemySpawner</code> and <code>BossSpawner</code>, as those two share most of their functionality. Especially, well, the laser mechanic.</p><p id="f0a6a4cb-413e-47d9-9b37-5452698d0a13" class="">Initially, a laser room has 4 lasers. But dependent on the door layout, not all of them are needed. Here, I also tried different approaches: Storing the laser configuration in some kind of bit mask would have required a special setup for each room. I decided to again make use of collisions as the laser was already able to collide with both the player and the <code>DoorTrigger</code>s. If any laser collided with a wall (which is different from a door), it would destroy itself. That of course, leaded to <code>NullReference</code>s. That’s why I added a <code>public</code> method that a laser could call in the <code>Spawner</code> to remove itself from the list.</p><ul id="9dc45745-ec05-4add-b35f-4727e0cb8316" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script] </em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em>LaserRoomSpawner.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c6eff0d2-59c6-40fd-b37f-890ffd16e841" class="code"><code class="language-C#">public abstract class LaserRoomSpawner : Spawner
{
    protected const int LaserOffset = NumberOfDoors;
    private readonly List&lt;Laser&gt; _lasers = new();

		// called by both child classes EnemySpawner and BossSpawner when needed
    protected void InitLasers()
    {
        for (int i = 0; i &lt; NumberOfDoors; i++)
        {
            _lasers.Add(transform.GetChild(i + LaserOffset).GetComponent&lt;Laser&gt;());
        }
    }
	
		// called by any laser at an invalid position (= no door)
    public void RemoveFromLaserList(Laser laser)
    {
        _lasers.Remove(laser);
    }

    protected void CloseLasers()
    {
        foreach (Laser laser in _lasers) laser.ActivateLaser();
    }

    protected void OpenLasers()
    {
        foreach (Laser laser in _lasers) laser.DeactivateLaser();
    }
}</code></pre></details></li></ul><ul id="fbb0b127-1afb-4b21-8f08-a2af6640c972" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em></em></em></em></em> Laser.cs (excerpt)</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="10520073-535c-414d-b4fa-cee061a32df6" class="code"><code class="language-C#">private void OnTriggerEnter2D(Collider2D other)
{
    if (!other.HasTag(&quot;Obstacle&quot;)) return;
    RemoveLaserThatHasNoDoorBehindIt();
}

private void RemoveLaserThatHasNoDoorBehindIt()
{
		// parent is the object with the laser room spawner component
    _parent.RemoveFromLaserList(this);
    Destroy(gameObject);
}

public void ActivateLaser()
{
    if (_laser.IsUnityNull()) return;
    _laser.gameObject.SetActive(true);
}</code></pre></details></li></ul><p id="48375547-8a3b-4bb5-8aac-9be6eb116041" class="">For spawning both enemies and boss minions I used another two object pools. We wanted to spawn more enemies the smaller the distance to the boss was. For the room generation, I determined the position holding the boss room right after the start room before filling the rest of the map. This way, I could calculate the boss distance any time an enemy room was chosen and tell the room how many enemies it should spawn based on the distance. The room would then request this number at the pool when the player entered. To balance the enemy spawns, I defined some fixed spawn points to pick from:</p><figure id="03c7fed2-0c04-42ec-bb61-e701a6fc547b" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%209.png"><img style="width:672px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%209.png"/></a><figcaption>6 spawn points in enemy room</figcaption></figure><ul id="1e5c61b7-4397-4305-a5f6-cc539de6b32d" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em></em> EnemySpawner.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1a794603-7a70-45ed-ba0f-5b1cff343b97" class="code"><code class="language-C#">public class EnemySpawner : LaserRoomSpawner
{
    [SerializeField] private int numberOfSpawnPoints = 6;

    private const int SpawnPointIndexOffset = NumberOfDoors + LaserOffset;
    private EnemyPool _pool;
    private List&lt;Transform&gt; _spawnPoints;
    private int _enemyCount;
    

    private void Start()
    {
        // use find with tag as this room will be instantiated after entering play mode
        _pool = GameObject.FindWithTag(&quot;EnemyPool&quot;).GetComponent&lt;EnemyPool&gt;();
        InitSpawnPoints();
        // method in super class
        InitLasers();
    }

    private void InitSpawnPoints()
    {
        _spawnPoints = new List&lt;Transform&gt;();


        for (int i = 0; i &lt; numberOfSpawnPoints; i++)
        {
            // avoid null references and display meaningful error message to help fixing errors
            if (i &gt;= transform.childCount)
            {
                Debug.LogError($&quot;Not enough spawn points in children of spawner. Failed at index {i}&quot;);
                break;
            }

		        // first &lt;numDoors&gt; children are colliders, rest are spawn points
            _spawnPoints.Add(transform.GetChild(i + SpawnPointIndexOffset));
        }
    }

    // called by RoomGenerator when instantiating enemy room
    public void SetEnemyCount(int enemyCount)
    {
        _enemyCount = enemyCount;
    }


    #region Spawn

    protected override void SpawnThing()
    {
        CloseLasers();
        SpawnEnemies();
        SubToPoolEvents();
    }

    private void SpawnEnemies()
    {
        var positionsToSpawn = SelectSpawnPointPositionsAndDeleteOthers();
        _pool.SpawnEnemies(_enemyCount, positionsToSpawn);
    }

    private List&lt;Vector3&gt; SelectSpawnPointPositionsAndDeleteOthers()
    {
        _spawnPoints = _spawnPoints.Shuffle(); // extension method
        // traverse loop backwards to avoid concurrent modification errors
        for (int i = _enemyCount - 1; i &gt;= _enemyCount; i++)
        {
            Destroy(_spawnPoints[i].gameObject);
            _spawnPoints.Pop(); // extension method
        }

        return _spawnPoints.Select(point =&gt; point.position).ToList();
    }

    #endregion


    #region Events

    private void SubToPoolEvents()
    {
        EnemyPool.OnAllEnemiesDefeated += OpenLasers;
        EnemyPool.OnAllEnemiesDefeated += UnsubFromPoolEvents;
    }

    private void UnsubFromPoolEvents()
    {
        EnemyPool.OnAllEnemiesDefeated -= OpenLasers;
        EnemyPool.OnAllEnemiesDefeated -= UnsubFromPoolEvents;
    }

    private void OnDisable()
    {
        UnsubFromPoolEvents();
    }

    private void OnDestroy()
    {
        UnsubFromPoolEvents();
    }

    #endregion
}</code></pre></details></li></ul><p id="8c6f409e-df3d-4b04-8299-ad4018fa09bf" class="">An issue I observed during playtesting was that some players immediately died from the boss because they were entering the boss room with only one life left. The problem was that the boss was so big that, when entering from either the top or bottom door, the player almost instantly ran into the boss and got damaged. To counteract that, I added that the boss would spawn a bit higher if the player entered from the room below, and a bit lower if the player entered from above. For left and right I didn’t need such a mechanism as the doors were further away from the room’s center. After some testing, I defined two spawn positions like so:</p><figure id="d95acb10-a15b-4aae-9c4b-bb0506b3e2aa" class="image"><a href="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%2010.png"><img style="width:672px" src="Roboom%200c119e4abe414410a85ad43e025bd2a1/Untitled%2010.png"/></a><figcaption>Boss room with spawn colliders and spawn positions</figcaption></figure><p id="f27c9722-736e-4c27-98c0-29ded1222464" class="">I also had a default spawn position in the middle for the case that the player came from the sides. Here you can have a look at the script:</p><ul id="68dd0a9e-b1e4-44e2-a287-b655a28700b5" class="toggle"><li><details open=""><summary><em><em><em><em><em>[Script]</em></em></em></em></em> BossSpawner.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="11e17020-99e1-4cd4-b436-0b046f7eb73b" class="code"><code class="language-C#">public class BossSpawner : LaserRoomSpawner
{
    [HideInInspector] public Direction directionPlayerEnters;
    [SerializeField] private Transform spawnPointUp;
    [SerializeField] private Transform spawnPointDown;
    private Transform _spawnPointDefault;
    private BossLogic _boss;

    private void Start()
    {
				// method of super class
        InitLasers();
				// use FindWithTag as room gets instantiated after entering play mode
        _boss = GameObject.FindWithTag(&quot;Boss&quot;).GetComponent&lt;BossLogic&gt;();
        _spawnPointDefault = transform;
    }

    protected override void SpawnThing()
    {
        CloseLasers();
        SpawnBoss();
        SubToBossEvent();
    }

    private void SpawnBoss()
    {
        // move boss if player entered from below or above to avoid insta-death
        Transform usedSpawnPoint = directionPlayerEnters switch
        {
            Direction.North =&gt; spawnPointDown,
            Direction.South =&gt; spawnPointUp,
            _ =&gt; _spawnPointDefault
        };
        
        _boss.Spawn(usedSpawnPoint.position);
    }

    private void SubToBossEvent()
    {
        BossLogic.OnBossDefeated += OpenLasers;
    }

    private void OnDestroy()
    {
        BossLogic.OnBossDefeated -= OpenLasers;
    }
}</code></pre></details></li></ul><p id="a73b2af8-306d-4d07-8778-59ef91d8c2f5" class="">Item and health room function nearly the same. So I created an <code>ItemSpawner</code> and let <code>HealthSpawner</code> inherit from it. The only thing that I needed to change was what to spawn, because there is only one health item, so it was clear what to spawn in a health room. But the item rooms could contain one out of three different powerups, so I had to make sure there were no duplicates. I used a combined pool for those 2, called <code>ItemData</code>:</p><ul id="968a9f7f-1551-48e5-ac69-c241acebb9cd" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em>[Script] </em></em></em></em></em></em></em>ItemSpawner.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b7464697-3297-4f6e-8091-738b5016b32a" class="code"><code class="language-C#">public class ItemSpawner : Spawner
{
    protected Transform Item;
    protected ItemData ItemData;

    private void Start()
    {
				// find with tag because item room is not in the scene from the start
        ItemData = GameObject.FindWithTag(&quot;ItemData&quot;).GetComponent&lt;ItemData&gt;();
        InitItem();
    }

    protected virtual void InitItem()
    {
        // item should be different from those that were already spawned
        Item = ItemData.GetNextItem();
    }

    protected override void SpawnThing()
    {
        Item.parent = transform.parent;
				// move object to parent by setting local pos to (0/0/0)
        Item.ResetLocalPosition();
    }
}</code></pre></details></li></ul><ul id="a92a5cee-6a95-4a5b-ba4c-76410ff4b45c" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em>[Script]</em></em></em></em></em></em></em> HealthSpawner.cs</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0111ad80-cf71-4e2b-abd7-0e4f47477a23" class="code"><code class="language-C#">public class HealthSpawner : ItemSpawner
{
    protected override void InitItem()
    {
        Item = ItemData.GetHealthItem();
    }
}</code></pre></details></li></ul><p id="ce385054-177f-4d01-b17d-29d1a7821990" class="">
</p><p id="2c2b62d7-0715-44e1-ac32-bb969b022987" class="">
</p><p id="afe977d4-9c34-4ee5-bd18-d968d360efa6" class=""><strong><mark class="highlight-brown">Music Data</mark></strong></p><p id="dd64f6e9-01f9-4fc4-b5bd-c1a8ea2e7852" class="">As the music heavily depended on the room layout, the player’s and the boss’ positions and the adjacent rooms, I provided a class holding all relevant data determining the music’s state together with some methods for pretty logs which simplified debugging a lot. I wanted to build a communication layer between the map logic and the music to keep things in order.</p><p id="1805e8df-cd31-418f-904e-8580f8480499" class="">The music only needed to be updated if the player switched the room, because then all the adjacent rooms’ contents will determine which music layers to play. That’s why I added an event holding all relevant data so Maxi (who was implementing the actual music using FMOD) would have all information he needed ready to use in an event.</p><p id="26b085b1-5502-4bd5-97e7-7c9f5fea96c0" class="">I wanted his scripts to only depend on this <code>MusicData</code> script I had added, so I subscribed on the <code>DoorTrigger</code>&#x27;s <code>RoomSwitch</code> event and delegated it to him. Here is the full script (without uninteresting getters etc):</p><ul id="5108d475-1a56-403b-917c-1ac3e3ff1afd" class="toggle"><li><details open=""><summary><em><em><em><em><em><em><em><em><em><em><em><em><em><em>[Script] </em></em></em></em></em></em></em></em></em></em></em></em></em></em>MusicData.cs (shortened)</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9909b0ab-aacc-48e1-a516-326013fb6997" class="code"><code class="language-C#">public class MusicData : MonoBehaviour
{
    public delegate void MusicAction(int distanceToBoss, IEnumerable&lt;RoomType&gt; adjacentRooms);
    public static event MusicAction OnRoomSwitch;
    
    private static bool _printLogs = true;

    private static RoomGenerator _roomGenerator;
    private static RoomGrid _roomGrid;
    
    private static Vector2Int _startRoomPos;
    private static Vector2Int _bossRoomPos;
    private static Vector2Int _currentGridPos;
    private static int _distanceToBoss;


    #region Events

    private static void RaiseEvent()
    {
        OnRoomSwitch?.Invoke(_distanceToBoss, GetAdjacentRooms());
        if (_printLogs) LogEventRaise();
    }

    private void Awake()
    {
        _roomGenerator = GameObject.FindWithTag(&quot;RoomGenerator&quot;).GetComponent&lt;RoomGenerator&gt;();

        RoomGenerator.OnGeneratedStartRoom += SetStartRoom;
        RoomGenerator.OnGeneratedBossRoom += SetBossRoom;
        DoorTrigger.OnRoomSwitch += UpdateGridValuesAndFireEvent;

        DeactivateLogs();
    }

    private static void SetStartRoom(Vector3 pos)
    {
        _roomGrid = _roomGenerator.GetRoomGrid();
        _startRoomPos = _roomGrid.MapPositionToGridPos(pos);
        _currentGridPos = _startRoomPos;
    }

    private static void SetBossRoom(Vector3 pos)
    {
        _bossRoomPos = pos.ToVec2Int();
        UpdateDistanceToBoss();
        if (_printLogs) LogCurrentState();
        RaiseEvent();
    }
    
    private void OnDestroy()
    {
        RoomGenerator.OnGeneratedStartRoom -= SetStartRoom;
        RoomGenerator.OnGeneratedBossRoom -= SetBossRoom;
        DoorTrigger.OnRoomSwitch -= UpdateGridValuesAndFireEvent;
    }

    #endregion

    #region Updates

    private static void UpdateGridValuesAndFireEvent(Vector3 _, Direction direction)
    {
        UpdateCurrentGridPosition(direction);
        UpdateDistanceToBoss();
        if (_printLogs) LogCurrentState();
        RaiseEvent();
    }

		// update methods [...]

    #endregion

    // Getters [...]

    #region Logging

		// change the consoles log entry length to see the full log ;)
    private static void LogCurrentState()
    {
        string log = &quot;MusicData:\n&quot;
                     + $&quot; + Current position is {_currentGridPos}\n&quot;
                     + $&quot; + Current room is [ {GetCurrentRoom()} ]\n&quot;
                     + $&quot; + Adjacent rooms are: {GetAdjacentRooms().Print(false)}\n&quot;
                     + $&quot; + BossRoom is at {_bossRoomPos}\n&quot;
                     + $&quot; + Distance to Boss is {GetDistanceToBoss()}&quot;;

        Debug.Log(log);
    }

    private static void LogEventRaise()
    {
        Debug.Log(
            $&quot;raise event: distance = {_distanceToBoss}, current = {GetCurrentRoom()}, adjacent = {GetAdjacentRooms().Print(false)}&quot;);
    }

    #endregion
    
}</code></pre></details></li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>